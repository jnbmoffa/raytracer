--------------------------------------------------------------------------------
Profile data file 'callgrind.out.8921' (creator: callgrind-3.10.1)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 9701461146
Trigger: Program termination
Profiled target:  ../rt ../lua/sample.lua (PID 8921, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
            Ir 
--------------------------------------------------------------------------------
76,756,035,522  PROGRAM TOTALS

--------------------------------------------------------------------------------
            Ir  file:function
--------------------------------------------------------------------------------

76,755,134,376  *  ???:0x00000000000012d0 [/lib/x86_64-linux-gnu/ld-2.19.so]

76,753,341,686  < ???:0x00000000000012d0 (1x) [/lib/x86_64-linux-gnu/ld-2.19.so]
76,753,341,686  *  ???:0x0000000000403ac0 [/home/jnbmoffa/git/raytracer/rt]

76,753,340,000  < ???:0x0000000000403ac0 (1x) [/home/jnbmoffa/git/raytracer/rt]
76,753,340,000  *  /build/buildd/eglibc-2.19/csu/libc-start.c:(below main) [/lib/x86_64-linux-gnu/libc-2.19.so]

76,753,237,357  < /build/buildd/eglibc-2.19/csu/libc-start.c:(below main) (1x) [/lib/x86_64-linux-gnu/libc-2.19.so]
76,753,237,357  *  /home/jnbmoffa/git/raytracer/src/main.cpp:main

76,753,230,040  *  main.cpp:main [/home/jnbmoffa/git/raytracer/rt]

76,753,220,290  < main.cpp:main (1x) [/home/jnbmoffa/git/raytracer/rt]
76,753,220,290  *  /home/jnbmoffa/git/raytracer/src/scene_lua.cpp:run_lua(std::string const&)

76,753,220,290  *  scene_lua.cpp:run_lua(std::string const&) [/home/jnbmoffa/git/raytracer/rt]

        28,270  < ???:lua_newstate (1x) [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]
76,752,839,934  < ???:0x000000000000c520 (2x) [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]
76,752,868,204  *  ???:0x000000000000b690 [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]

       426,611  < ???:0x000000000000c610 (1x) [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]
76,752,413,367  < ???:lua_pcall (1x) [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]
76,752,839,978  *  ???:0x000000000000c520 [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]

76,752,359,457  < ???:0x00000000000159d0 (52x) [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]
           146  < ???:0x0000000000007050 (1x) [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]
       285,418  < ???:0x000000000000c350 (8x) [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]
76,752,645,021  *  ???:0x000000000000bd70 [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]

76,752,413,390  < scene_lua.cpp:run_lua(std::string const&) (1x) [/home/jnbmoffa/git/raytracer/rt]
76,752,413,390  *  ???:lua_pcall [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]

76,752,413,303  < ???:0x000000000000b690 (1x) [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]
76,752,413,303  *  ???:0x0000000000007050 [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]

76,752,413,136  < ???:0x0000000000007050 (1x) [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]
76,752,413,136  *  ???:0x00000000000159d0 [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]

76,752,222,485  < ???:0x000000000000bd70 (1x) [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]
76,752,222,485  *  /home/jnbmoffa/git/raytracer/src/scene_lua.cpp:gr_render_cmd

76,752,222,322  *  scene_lua.cpp:gr_render_cmd [/home/jnbmoffa/git/raytracer/rt]

76,752,219,721  < scene_lua.cpp:gr_render_cmd (1x) [/home/jnbmoffa/git/raytracer/rt]
76,752,219,721  *  /home/jnbmoffa/git/raytracer/src/render.cpp:render(std::unique_ptr<SceneNode, std::default_delete<SceneNode> >&&, std::string const&, int, int, std::shared_ptr<LuaCamera>, Colour const&, std::list<std::unique_ptr<Light, std::default_delete<Light> >, std::allocator<std::unique_ptr<Light, std::default_delete<Light> > > > const&, int, double, int)

76,752,198,669  *  scenecontainer.h:render(std::unique_ptr<SceneNode, std::default_delete<SceneNode> >&&, std::string const&, int, int, std::shared_ptr<LuaCamera>, Colour const&, std::list<std::unique_ptr<Light, std::default_delete<Light> >, std::allocator<std::unique_ptr<Light, std::default_delete<Light> > > > const&, int, double, int)

76,752,182,986  < scenecontainer.h:render(std::unique_ptr<SceneNode, std::default_delete<SceneNode> >&&, std::string const&, int, int, std::shared_ptr<LuaCamera>, Colour const&, std::list<std::unique_ptr<Light, std::default_delete<Light> >, std::allocator<std::unique_ptr<Light, std::default_delete<Light> > > > const&, int, double, int) (1x)
76,752,182,986  *  /home/jnbmoffa/git/raytracer/src/photonmap.cpp:PhotonMap::BuildTree()

75,412,050,386  *  photonmap.cpp:PhotonMap::BuildTree() [/home/jnbmoffa/git/raytracer/rt]

75,356,725,049  < photonmap.cpp:PhotonMap::BuildTree() (6147255x) [/home/jnbmoffa/git/raytracer/rt]
75,356,725,049  *  photonmap.cpp:PhotonMap::TracePhoton(Ray const&, Colour const&, unsigned int, bool) [/home/jnbmoffa/git/raytracer/rt]

75,018,566,746  *  scenecontainer.cpp:SceneContainer::PhotonTrace(Ray const&, HitInfo&) [/home/jnbmoffa/git/raytracer/rt]

 4,988,896,455  < photonmap.cpp:PhotonMap::TracePhoton(Ray const&, Colour const&, unsigned int, bool)'2 (369869x) [/home/jnbmoffa/git/raytracer/rt]
70,029,670,291  < photonmap.cpp:PhotonMap::TracePhoton(Ray const&, Colour const&, unsigned int, bool) (6147255x) [/home/jnbmoffa/git/raytracer/rt]
75,018,566,746  *  /home/jnbmoffa/git/raytracer/src/scenecontainer.cpp:SceneContainer::PhotonTrace(Ray const&, HitInfo&)

74,999,015,374  < scenecontainer.cpp:SceneContainer::PhotonTrace(Ray const&, HitInfo&) (6517124x) [/home/jnbmoffa/git/raytracer/rt]
74,999,015,374  *  scenecontainer.cpp:SceneContainer::ContainerSpecificColourTrace(Ray const&, HitInfo&) [/home/jnbmoffa/git/raytracer/rt]

70,358,823,264  < scenecontainer.cpp:SceneContainer::ContainerSpecificColourTrace(Ray const&, HitInfo&) (45619866x) [/home/jnbmoffa/git/raytracer/rt]
70,358,823,264  *  /home/jnbmoffa/git/raytracer/src/scene.cpp:GeometryNode::ColourTrace(Ray, double&, HitInfo&, Matrix4x4&)

47,275,171,068  *  scene.cpp:GeometryNode::ColourTrace(Ray, double&, HitInfo&, Matrix4x4&) [/home/jnbmoffa/git/raytracer/rt]

44,035,350,681  < scene.cpp:GeometryNode::ColourTrace(Ray, double&, HitInfo&, Matrix4x4&) (32585620x) [/home/jnbmoffa/git/raytracer/rt]
44,035,350,681  *  /home/jnbmoffa/git/raytracer/src/primitive.cpp:Cube::DepthTrace(Ray, double&, HitInfo&, Matrix4x4 const&)

16,290,994,342  *  primitive.hpp:Cube::DepthTrace(Ray, double&, HitInfo&, Matrix4x4 const&)

12,682,322,748  *  fastmath.h:GeometryNode::ColourTrace(Ray, double&, HitInfo&, Matrix4x4&)

12,577,459,273  *  /usr/include/c++/4.9/bits/stl_algobase.h:Cube::DepthTrace(Ray, double&, HitInfo&, Matrix4x4 const&)

        14,446  < scene.cpp:SceneNode::translate(FastMath::Vector<3ul, double> const&) (9x) [/home/jnbmoffa/git/raytracer/rt]
11,487,185,122  < primitive.hpp:Cube::DepthTrace(Ray, double&, HitInfo&, Matrix4x4 const&) (8038618x)
         4,287  < scene.cpp:SceneNode::rotate(char, double) (3x) [/home/jnbmoffa/git/raytracer/rt]
        10,003  < scene.cpp:GeometryNode::GeometryNode(std::string const&, std::shared_ptr<Primitive>, std::shared_ptr<Material>&, Matrix4x4, FastMath::Vector<3ul, double>) (7x) [/home/jnbmoffa/git/raytracer/rt]
        10,003  < scene.cpp:SceneNode::scale(FastMath::Vector<3ul, double> const&) (7x) [/home/jnbmoffa/git/raytracer/rt]
   396,407,458  < primitive.hpp:Sphere::DepthTrace(Ray, double&, HitInfo&, Matrix4x4 const&) (277402x)
11,883,631,319  *  /home/jnbmoffa/git/raytracer/src/algebra.cpp:Matrix4x4::invert() const

         1,799  < fastmath.h:SceneNode::FlattenScene(std::vector<std::unique_ptr<SceneNode, std::default_delete<SceneNode> >, std::allocator<std::unique_ptr<SceneNode, std::default_delete<SceneNode> > > >&, Matrix4x4) (7x)
           771  < fastmath.h:SceneNode::rotate(char, double) (3x)
         2,313  < fastmath.h:SceneNode::translate(FastMath::Vector<3ul, double> const&) (9x)
         1,799  < fastmath.h:SceneNode::scale(FastMath::Vector<3ul, double> const&) (7x)
11,724,305,562  < fastmath.h:GeometryNode::ColourTrace(Ray, double&, HitInfo&, Matrix4x4&) (45619866x)
         1,799  < fastmath.h:GeometryNode::FlattenScene(std::vector<std::unique_ptr<SceneNode, std::default_delete<SceneNode> >, std::allocator<std::unique_ptr<SceneNode, std::default_delete<SceneNode> > > >&, Matrix4x4) (7x)
11,724,314,043  *  fastmath.h:FastMath::MultMtxImpl<Matrix4x4, 4ul, 0ul, 0ul, 0ul>::eval(Matrix4x4&, Matrix4x4 const&, Matrix4x4 const&) [/home/jnbmoffa/git/raytracer/rt]

           204  < ???:char* std::string::_S_construct<char const*>(char const*, char const*, std::allocator<char> const&, std::forward_iterator_tag) (11x) [/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21]
 6,777,808,798  < /usr/include/c++/4.9/bits/stl_algobase.h:Cube::DepthTrace(Ray, double&, HitInfo&, Matrix4x4 const&) (423613050x)
            16  < ???:std::string::_M_replace_safe(unsigned long, unsigned long, char const*, unsigned long) (1x) [/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21]
 2,189,753,568  < /usr/include/c++/4.9/bits/stl_algobase.h:GeometryNode::ColourTrace(Ray, double&, HitInfo&, Matrix4x4&) (136859598x)
   266,113,472  < /usr/include/c++/4.9/bits/stl_algobase.h:Matrix4x4::invert() const (8316046x)
           112  < /usr/include/c++/4.9/bits/stl_algobase.h:GeometryNode::FlattenScene(std::vector<std::unique_ptr<SceneNode, std::default_delete<SceneNode> >, std::allocator<std::unique_ptr<SceneNode, std::default_delete<SceneNode> > > >&, Matrix4x4) (7x)
         4,659  < ???:0x0000000000013260 (239x) [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]
     1,479,472  < /usr/include/c++/4.9/bits/stl_algobase.h:PhotonMap::TracePhoton(Ray const&, Colour const&, unsigned int, bool)'2 (92467x)
            52  < ???:0x0000000000015710 (3x) [/usr/lib/x86_64-linux-gnu/liblua5.1.so.0.0.0]
 2,189,753,568  < /usr/include/c++/4.9/bits/stl_algobase.h:SceneContainer::ContainerSpecificColourTrace(Ray const&, HitInfo&) (136859598x)
           567  < /usr/include/c++/4.9/bits/stl_algobase.h:GeometryNode::GeometryNode(std::string const&, std::shared_ptr<Primitive>, std::shared_ptr<Material>&, Matrix4x4, FastMath::Vector<3ul, double>) (7x)
         5,396  < ???:0x00000000000a0f00 (284x) [/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21]
11,424,919,884  *  /build/buildd/eglibc-2.19/string/../sysdeps/x86_64/multiarch/memcpy-sse2-unaligned.S:__memcpy_sse2_unaligned [/lib/x86_64-linux-gnu/libc-2.19.so]

10,935,600,490  *  algebra.cpp:Matrix4x4::invert() const [/home/jnbmoffa/git/raytracer/rt]

 8,162,161,518  *  primitive.cpp:Cube::DepthTrace(Ray, double&, HitInfo&, Matrix4x4 const&) [/home/jnbmoffa/git/raytracer/rt]

 7,846,616,952  *  /usr/include/c++/4.9/bits/stl_algobase.h:GeometryNode::ColourTrace(Ray, double&, HitInfo&, Matrix4x4&)

 5,049,285,413  < photonmap.cpp:PhotonMap::TracePhoton(Ray const&, Colour const&, unsigned int, bool) (184935x) [/home/jnbmoffa/git/raytracer/rt]
 2,380,970,782  < photonmap.cpp:PhotonMap::TracePhoton(Ray const&, Colour const&, unsigned int, bool)'2 (184934x) [/home/jnbmoffa/git/raytracer/rt]
 7,430,256,195  *  photonmap.cpp:PhotonMap::TracePhoton(Ray const&, Colour const&, unsigned int, bool)'2 [/home/jnbmoffa/git/raytracer/rt]

 5,558,572,846  *  fastmath.h:Cube::DepthTrace(Ray, double&, HitInfo&, Matrix4x4 const&)

 4,790,042,496  < algebra.cpp:Matrix4x4::invert() const (199585104x) [/home/jnbmoffa/git/raytracer/rt]
 4,790,042,496  *  /home/jnbmoffa/git/raytracer/src/algebra.hpp:submultrow(Matrix4x4&, unsigned long, unsigned long, double)

 3,991,702,080  *  algebra.cpp:submultrow(Matrix4x4&, unsigned long, unsigned long, double)

 3,682,174,924  *  /usr/include/c++/4.9/bits/stl_algobase.h:SceneContainer::ContainerSpecificColourTrace(Ray const&, HitInfo&)

 2,821,709,043  < primitive.cpp:Cube::DepthTrace(Ray, double&, HitInfo&, Matrix4x4 const&) (97930854x) [/home/jnbmoffa/git/raytracer/rt]
 2,821,709,043  *  primitive.cpp:Cube::IsInside(FastMath::Point<3ul, double>, FastMath::Vector<3ul, double>) [/home/jnbmoffa/git/raytracer/rt]

 2,280,993,300  *  algebra.hpp:GeometryNode::ColourTrace(Ray, double&, HitInfo&, Matrix4x4&)

 1,579,125,601  < scene.cpp:GeometryNode::ColourTrace(Ray, double&, HitInfo&, Matrix4x4&) (13034246x) [/home/jnbmoffa/git/raytracer/rt]
 1,579,125,601  *  /home/jnbmoffa/git/raytracer/src/primitive.cpp:Sphere::DepthTrace(Ray, double&, HitInfo&, Matrix4x4 const&)

 1,397,095,728  < algebra.cpp:Matrix4x4::invert() const (66528368x) [/home/jnbmoffa/git/raytracer/rt]
 1,397,095,728  *  /home/jnbmoffa/git/raytracer/src/algebra.hpp:swaprows(Matrix4x4&, unsigned long, unsigned long)

 1,130,982,256  *  /usr/include/c++/4.9/bits/move.h:swaprows(Matrix4x4&, unsigned long, unsigned long)

   965,119,035  *  /usr/include/c++/4.9/bits/random.h:PhotonMap::BuildTree()

   831,606,185  *  /usr/include/c++/4.9/bits/stl_algobase.h:Matrix4x4::invert() const

   811,437,660  < /usr/include/c++/4.9/bits/random.h:PhotonMap::BuildTree() (18441765x)
   811,437,660  *  /usr/include/c++/4.9/bits/random.h:double std::generate_canonical<double, 53ul, std::linear_congruential_engine<unsigned long, 16807ul, 0ul, 2147483647ul> >(std::linear_congruential_engine<unsigned long, 16807ul, 0ul, 2147483647ul>&) [/home/jnbmoffa/git/raytracer/rt]

   798,340,416  *  algebra.hpp:submultrow(Matrix4x4&, unsigned long, unsigned long, double) [/home/jnbmoffa/git/raytracer/rt]

   785,016,824  *  fastmath.h:Sphere::DepthTrace(Ray, double&, HitInfo&, Matrix4x4 const&)

   782,054,880  *  /usr/include/x86_64-linux-gnu/bits/string3.h:Cube::DepthTrace(Ray, double&, HitInfo&, Matrix4x4 const&)

   664,107,822  *  algebra.hpp:Cube::DepthTrace(Ray, double&, HitInfo&, Matrix4x4 const&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/4.9/bits/move.h
--------------------------------------------------------------------------------
         Ir 

-- line 167 ----------------------------------------
          .  #if __cplusplus >= 201103L
          .      noexcept(__and_<is_nothrow_move_constructible<_Tp>,
          .  	            is_nothrow_move_assignable<_Tp>>::value)
          .  #endif
          .      {
          .        // concept requirements
          .        __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
          .  
266,113,472        _Tp __tmp = _GLIBCXX_MOVE(__a);
532,226,944        __a = _GLIBCXX_MOVE(__b);
332,641,849        __b = _GLIBCXX_MOVE(__tmp);
          .      }
          .  
          .    // _GLIBCXX_RESOLVE_LIB_DEFECTS
          .    // DR 809. std::swap should be overloaded for array types.
          .    /// Swap the contents of two arrays.
          .    template<typename _Tp, size_t _Nm>
          .      inline void
          .      swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
-- line 185 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jnbmoffa/git/raytracer/src/scene.cpp
--------------------------------------------------------------------------------
  No information has been collected for /home/jnbmoffa/git/raytracer/src/scene.cpp

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jnbmoffa/git/raytracer/src/algebra.cpp
--------------------------------------------------------------------------------
  No information has been collected for /home/jnbmoffa/git/raytracer/src/algebra.cpp

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jnbmoffa/git/raytracer/src/render.cpp
--------------------------------------------------------------------------------
  No information has been collected for /home/jnbmoffa/git/raytracer/src/render.cpp

--------------------------------------------------------------------------------
-- Auto-annotated source: scene_lua.cpp
--------------------------------------------------------------------------------
 Ir 

-- line 80 ----------------------------------------
  .  
  .  // The "userdata" type for a material. Objects of this type will be
  .  // allocated by Lua to represent materials.
  .  struct gr_material_ud {
  .    std::shared_ptr<Material> material;
  .  };
  .  
  .  // Store all the materials so their destructors can be called.
  5  std::vector<gr_material_ud*> materials;
 66  => /build/buildd/eglibc-2.19/stdlib/cxa_atexit.c:__cxa_atexit (1x)
  .  
  .  // The "userdata" type for a light. Objects of this type will be
  .  // allocated by Lua to represent lights.
  .  struct gr_light_ud {
  .    Light* light;
  .  };
  .  
  .  // The "userdata" type for a camera. Objects of this type will be
  .  // allocated by Lua to represent cameras.
  .  struct gr_camera_ud {
  .    std::shared_ptr<LuaCamera> camera;
  .  };
  .  
  .  // Store all the camera so their destructors can be called.
  5  std::vector<gr_camera_ud*> cameras;
 66  => /build/buildd/eglibc-2.19/stdlib/cxa_atexit.c:__cxa_atexit (1x)
  .  
  .  // Useful function to retrieve and check an n-tuple of numbers.
  .  template<typename T>
207  void get_tuple(lua_State* L, int arg, T* data, int n)
  .  {
 73    luaL_checktype(L, arg, LUA_TTABLE);
690  => ???:luaL_checktype (23x)
684  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
142    luaL_argcheck(L, luaL_getn(L, arg) == n, arg, "N-tuple expected");
1,288  => ???:lua_objlen (23x)
632  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
299    for (int i = 1; i <= n; i++) {
349      lua_rawgeti(L, arg, i);
2,622  => ???:lua_rawgeti (69x)
655  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
349      data[i - 1] = luaL_checknumber(L, -1);
714  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
3,599  => ???:luaL_checknumber (69x)
349      lua_pop(L, 1);
483  => ???:lua_settop (69x)
624  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
  .    }
138  }
  .  
  .  // Create a node
  .  extern "C"
  .  int gr_node_cmd(lua_State* L)
  5  {
  .    GRLUA_DEBUG_CALL;
  .    
  4    gr_node_ud* data = (gr_node_ud*)lua_newuserdata(L, sizeof(gr_node_ud));
301  => ???:lua_newuserdata (1x)
  1    data->node = 0;
  .  
  9    const char* name = luaL_checkstring(L, 1);
729  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
 40  => ???:luaL_checklstring (1x)
 16    data->node = new SceneNode(name);
1,284  => /home/jnbmoffa/git/raytracer/src/scene.cpp:SceneNode::SceneNode(std::string const&, Matrix4x4) (1x)
231  => ???:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (1x)
196  => ???:operator new(unsigned long) (1x)
  .  
  9    luaL_getmetatable(L, "gr.node");
277  => ???:lua_getfield (1x)
662  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
  4    lua_setmetatable(L, -2);
 32  => ???:lua_setmetatable (1x)
  .  
  .    return 1;
  6  }
  .  
  .  // Create a joint node
  .  extern "C"
  .  int gr_joint_cmd(lua_State* L)
  .  {
  .    GRLUA_DEBUG_CALL;
  .    
  .    gr_node_ud* data = (gr_node_ud*)lua_newuserdata(L, sizeof(gr_node_ud));
-- line 142 ----------------------------------------
-- line 158 ----------------------------------------
  .    lua_setmetatable(L, -2);
  .  
  .    return 1;
  .  }
  .  
  .  // Create a sphere node
  .  extern "C"
  .  int gr_sphere_cmd(lua_State* L)
 10  {
  .    GRLUA_DEBUG_CALL;
  .    
  8    gr_node_ud* data = (gr_node_ud*)lua_newuserdata(L, sizeof(gr_node_ud));
602  => ???:lua_newuserdata (2x)
  2    data->node = 0;
  .    
 10    const char* name = luaL_checkstring(L, 1);
 80  => ???:luaL_checklstring (2x)
 30    data->node = new GeometryNode(name, std::make_shared<Sphere>());
392  => ???:operator new(unsigned long) (2x)
654  => ???:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (2x)
550  => /home/jnbmoffa/git/raytracer/src/scene.cpp:GeometryNode::GeometryNode(std::string const&, std::shared_ptr<Primitive>, FastMath::Vector<3ul, double>) (2x)
  .  
 10    luaL_getmetatable(L, "gr.node");
554  => ???:lua_getfield (2x)
  8    lua_setmetatable(L, -2);
 64  => ???:lua_setmetatable (2x)
  .  
  .    return 1;
 12  }
  .  
  .  // Create a sphere node with velocity
  .  extern "C"
  .  int gr_velocity_sphere_cmd(lua_State* L)
  .  {
  .    GRLUA_DEBUG_CALL;
  .    
  .    gr_node_ud* data = (gr_node_ud*)lua_newuserdata(L, sizeof(gr_node_ud));
-- line 187 ----------------------------------------
-- line 196 ----------------------------------------
  .    lua_setmetatable(L, -2);
  .  
  .    return 1;
  .  }
  .  
  .  // Create a cube node
  .  extern "C"
  .  int gr_cube_cmd(lua_State* L)
 25  {
  .    GRLUA_DEBUG_CALL;
  .    
 20    gr_node_ud* data = (gr_node_ud*)lua_newuserdata(L, sizeof(gr_node_ud));
1,505  => ???:lua_newuserdata (5x)
  5    data->node = 0;
  .    
 25    const char* name = luaL_checkstring(L, 1);
200  => ???:luaL_checklstring (5x)
 75    data->node = new GeometryNode(name, std::make_shared<Cube>());
980  => ???:operator new(unsigned long) (5x)
1,375  => /home/jnbmoffa/git/raytracer/src/scene.cpp:GeometryNode::GeometryNode(std::string const&, std::shared_ptr<Primitive>, FastMath::Vector<3ul, double>) (5x)
1,654  => ???:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (5x)
  .  
 25    luaL_getmetatable(L, "gr.node");
1,385  => ???:lua_getfield (5x)
 20    lua_setmetatable(L, -2);
160  => ???:lua_setmetatable (5x)
  .  
  .    return 1;
 30  }
  .  
  .  // Create a cylinder node
  .  extern "C"
  .  int gr_cylinder_cmd(lua_State* L)
  .  {
  .    GRLUA_DEBUG_CALL;
  .    
  .    gr_node_ud* data = (gr_node_ud*)lua_newuserdata(L, sizeof(gr_node_ud));
-- line 225 ----------------------------------------
-- line 358 ----------------------------------------
  .    lua_setmetatable(L, -2);
  .  
  .    return 1;
  .  }
  .  
  .  // Make a point light
  .  extern "C"
  .  int gr_light_cmd(lua_State* L)
  6  {
  .    GRLUA_DEBUG_CALL;
  .  
  4    gr_light_ud* data = (gr_light_ud*)lua_newuserdata(L, sizeof(gr_light_ud));
301  => ???:lua_newuserdata (1x)
  1    data->light = 0;
  .    
  2    Light l;
 13  => /home/jnbmoffa/git/raytracer/src/algebra.hpp:Light::Light() (1x)
  .  
  .    double col[3];
  .    // power
  5    l.power = luaL_checknumber(L, 1);
 31  => ???:luaL_checknumber (1x)
  6    get_tuple(L, 2, &l.position[0], 3);
438  => scene_lua.cpp:void get_tuple<double>(lua_State*, int, double*, int) (1x)
  5    get_tuple(L, 3, col, 3);
390  => scene_lua.cpp:void get_tuple<double>(lua_State*, int, double*, int) (1x)
  5    get_tuple(L, 4, l.falloff, 3);
438  => scene_lua.cpp:void get_tuple<double>(lua_State*, int, double*, int) (1x)
  .  
  .    l.colour = Colour(col[0], col[1], col[2]);
  .    
  5    data->light = new Light(l);
109  => ???:operator new(unsigned long) (1x)
  .  
  4    luaL_newmetatable(L, "gr.light");
1,498  => ???:luaL_newmetatable (1x)
  4    lua_setmetatable(L, -2);
 35  => ???:lua_setmetatable (1x)
  .  
  .    return 1;
  7  }
  .  
  .  // Make area point light
  .  extern "C"
  .  int gr_alight_cmd(lua_State* L)
  .  {
  .    GRLUA_DEBUG_CALL;
  .  
  .    gr_light_ud* data = (gr_light_ud*)lua_newuserdata(L, sizeof(gr_light_ud));
-- line 397 ----------------------------------------
-- line 416 ----------------------------------------
  .    lua_setmetatable(L, -2);
  .  
  .    return 1;
  .  }
  .  
  .  // Make a camera
  .  extern "C"
  .  int gr_pcamera_cmd(lua_State* L)
  7  {
  .    GRLUA_DEBUG_CALL;
  .  
  4    gr_camera_ud* data = (gr_camera_ud*)lua_newuserdata(L, sizeof(gr_camera_ud));
301  => ???:lua_newuserdata (1x)
  2    new (&(data->camera)) std::shared_ptr<LuaCamera>();  // Placement new
  .    
  3    cameras.emplace_back(data);
167  => /usr/include/c++/4.9/bits/vector.tcc:void std::vector<gr_camera_ud*, std::allocator<gr_camera_ud*> >::emplace_back<gr_camera_ud*&>(gr_camera_ud*&) (1x)
  .  
  .    LuaCamera c;
  .  
  5    get_tuple(L, 1, &(c.eye[0]), 3);
414  => scene_lua.cpp:void get_tuple<double>(lua_State*, int, double*, int) (1x)
  6    get_tuple(L, 2, &(c.view[0]), 3);
438  => scene_lua.cpp:void get_tuple<double>(lua_State*, int, double*, int) (1x)
  6    get_tuple(L, 3, &(c.up[0]), 3);
438  => scene_lua.cpp:void get_tuple<double>(lua_State*, int, double*, int) (1x)
  5    c.fov = luaL_checknumber(L, 4);
 31  => ???:luaL_checknumber (1x)
  1    c.ApertureRadius = 0;
  2    c.FocalDistance = 1;
  1    c.DOFRays = 1;
  .    
  1    data->camera = std::make_shared<LuaCamera>(c);
  .  
  4    luaL_newmetatable(L, "gr.camera");
1,429  => ???:luaL_newmetatable (1x)
  4    lua_setmetatable(L, -2);
 35  => ???:lua_setmetatable (1x)
  .  
  .    return 1;
  8  }
  .  
  .  // Make a camera
  .  extern "C"
  .  int gr_lcamera_cmd(lua_State* L)
  .  {
  .    GRLUA_DEBUG_CALL;
  .  
  .    gr_camera_ud* data = (gr_camera_ud*)lua_newuserdata(L, sizeof(gr_camera_ud));
-- line 456 ----------------------------------------
-- line 474 ----------------------------------------
  .    lua_setmetatable(L, -2);
  .  
  .    return 1;
  .  }
  .  
  .  // Render a scene
  .  extern "C"
  .  int gr_render_cmd(lua_State* L)
  9  {
  .    GRLUA_DEBUG_CALL;
  .    
  5    gr_node_ud* root = (gr_node_ud*)luaL_checkudata(L, 1, "gr.node");
435  => ???:luaL_checkudata (1x)
  2    luaL_argcheck(L, root != 0, 1, "Root node expected");
  .  
  6    const char* filename = luaL_checkstring(L, 2);
 40  => ???:luaL_checklstring (1x)
  .  
  6    int width = luaL_checknumber(L, 3);
 31  => ???:luaL_checknumber (1x)
  6    int height = luaL_checknumber(L, 4);
 31  => ???:luaL_checknumber (1x)
  .  
  6    gr_camera_ud* cdata = (gr_camera_ud*)luaL_checkudata(L, 5, "gr.camera");
441  => ???:luaL_checkudata (1x)
  2    luaL_argcheck(L, cdata != 0, 5, "Camera expected");
  .    std::shared_ptr<LuaCamera> cam = cdata->camera;
  .  
  .    double ambient_data[3];
  5    get_tuple(L, 6, ambient_data, 3);
390  => scene_lua.cpp:void get_tuple<double>(lua_State*, int, double*, int) (1x)
  .    Colour ambient(ambient_data[0], ambient_data[1], ambient_data[2]);
  .  
  5    luaL_checktype(L, 7, LUA_TTABLE);
 30  => ???:luaL_checktype (1x)
  5    int light_count = luaL_getn(L, 7);
 56  => ???:lua_objlen (1x)
  .    
  .    // luaL_argcheck(L, light_count >= 1, 7, "Tuple of lights expected");
  .    std::list<std::unique_ptr<Light>> lights;
  8    for (int i = 1; i <= light_count; i++) {
  5      lua_rawgeti(L, 7, i);
 38  => ???:lua_rawgeti (1x)
  6      gr_light_ud* ldata = (gr_light_ud*)luaL_checkudata(L, -1, "gr.light");
431  => ???:luaL_checkudata (1x)
  2      luaL_argcheck(L, ldata != 0, 7, "Light expected");
  .  
  .      lights.emplace_back(ldata->light);
  4      lua_pop(L, 1);
  7  => ???:lua_settop (1x)
  .    }
  .  
  5    luaL_checktype(L, 8, LUA_TTABLE);
 30  => ???:luaL_checktype (1x)
  5    int alight_count = luaL_getn(L, 8);
 50  => ???:lua_objlen (1x)
  .    
  .    // luaL_argcheck(L, light_count >= 1, 8, "Tuple of lights expected");
  2    for (int i = 1; i <= alight_count; i++) {
  .      lua_rawgeti(L, 8, i);
  .      gr_light_ud* ldata = (gr_light_ud*)luaL_checkudata(L, -1, "gr.alight");
  .      luaL_argcheck(L, ldata != 0, 8, "Area Light expected");
  .  
  .      lights.emplace_back(ldata->light);
  .      lua_pop(L, 1);
  .    }
  .  
  5    int Photons = luaL_checknumber(L, 9);
 31  => ???:luaL_checknumber (1x)
  6    int D = luaL_checknumber(L, 10);
 57  => ???:luaL_checknumber (1x)
  5    int Steps = luaL_checknumber(L, 11);
 31  => ???:luaL_checknumber (1x)
  .  
 20    render(std::unique_ptr<SceneNode>(root->node), filename, width, height, cam, ambient, lights, Photons, D, Steps);
76,752,219,721  => /home/jnbmoffa/git/raytracer/src/render.cpp:render(std::unique_ptr<SceneNode, std::default_delete<SceneNode> >&&, std::string const&, int, int, std::shared_ptr<LuaCamera>, Colour const&, std::list<std::unique_ptr<Light, std::default_delete<Light> >, std::allocator<std::unique_ptr<Light, std::default_delete<Light> > > > const&, int, double, int) (1x)
342  => ???:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (1x)
  .    
  .    return 0;
  .  }
  .  
  .  // Create a material
  .  extern "C"
  .  int gr_material_cmd(lua_State* L)
 35  {
  .    GRLUA_DEBUG_CALL;
  .    
 32    gr_material_ud* data = (gr_material_ud*)lua_newuserdata(L, sizeof(gr_material_ud));
699  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
2,129  => ???:lua_newuserdata (7x)
 14    new (&(data->material)) std::shared_ptr<Material>();  // Placement new
  .    
 21    materials.emplace_back(data);
4,414  => /usr/include/c++/4.9/bits/vector.tcc:void std::vector<gr_material_ud*, std::allocator<gr_material_ud*> >::emplace_back<gr_material_ud*&>(gr_material_ud*&) (7x)
  .  
  .    double kd[3], ks[3];
 35    get_tuple(L, 1, kd, 3);
7,369  => scene_lua.cpp:void get_tuple<double>(lua_State*, int, double*, int) (7x)
 35    get_tuple(L, 2, ks, 3);
2,730  => scene_lua.cpp:void get_tuple<double>(lua_State*, int, double*, int) (7x)
  .  
 35    double shininess = luaL_checknumber(L, 3);
217  => ???:luaL_checknumber (7x)
  .    
  7    data->material = std::make_shared<PhongMaterial>(Colour(kd[0], kd[1], kd[2]),
  .                                                     Colour(ks[0], ks[1], ks[2]),
  .                                                     shininess);
  .  
 28    luaL_newmetatable(L, "gr.material");
5,109  => ???:luaL_newmetatable (7x)
 32    lua_setmetatable(L, -2);
245  => ???:lua_setmetatable (7x)
722  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
  .    
  .    return 1;
 42  }
  .  
  .  extern "C"
  .  int gr_smaterial_cmd(lua_State* L)
  5  {
  .    GRLUA_DEBUG_CALL;
  .    
  4    gr_material_ud* data = (gr_material_ud*)lua_newuserdata(L, sizeof(gr_material_ud));
281  => ???:lua_newuserdata (1x)
  2    new (&(data->material)) std::shared_ptr<Material>();  // Placement new
  .  
  3    materials.emplace_back(data);
361  => /usr/include/c++/4.9/bits/vector.tcc:void std::vector<gr_material_ud*, std::allocator<gr_material_ud*> >::emplace_back<gr_material_ud*&>(gr_material_ud*&) (1x)
  .  
  .    double kd[3], ks[3];
  5    get_tuple(L, 1, kd, 3);
462  => scene_lua.cpp:void get_tuple<double>(lua_State*, int, double*, int) (1x)
  5    get_tuple(L, 2, ks, 3);
390  => scene_lua.cpp:void get_tuple<double>(lua_State*, int, double*, int) (1x)
  .  
  5    double shininess = luaL_checknumber(L, 3);
 31  => ???:luaL_checknumber (1x)
  5    double refractive = luaL_checknumber(L, 4);
 31  => ???:luaL_checknumber (1x)
  5    double refractiveIndex = luaL_checknumber(L, 5);
 31  => ???:luaL_checknumber (1x)
  5    double glossiness = luaL_checknumber(L, 6);
 57  => ???:luaL_checknumber (1x)
  .    
  1    data->material = std::make_shared<PhongMaterial>(Colour(kd[0], kd[1], kd[2]),
  .                                                     Colour(ks[0], ks[1], ks[2]),
  .                                                     shininess,
  7                                                     refractive != 0.f,
  .                                                     refractiveIndex,
  .                                                     glossiness);
  .  
  4    luaL_newmetatable(L, "gr.material");
349  => ???:luaL_newmetatable (1x)
  4    lua_setmetatable(L, -2);
 35  => ???:lua_setmetatable (1x)
  .    
  .    return 1;
  6  }
  .  
  .  // Add a child to a node
  .  extern "C"
  .  int gr_node_add_child_cmd(lua_State* L)
 28  {
  .    GRLUA_DEBUG_CALL;
  .    
 39    gr_node_ud* selfdata = (gr_node_ud*)luaL_checkudata(L, 1, "gr.node");
4,721  => ???:luaL_checkudata (7x)
699  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
 14    luaL_argcheck(L, selfdata != 0, 1, "Node expected");
  .  
  7    SceneNode* self = selfdata->node;
  .    
 42    gr_node_ud* childdata = (gr_node_ud*)luaL_checkudata(L, 2, "gr.node");
2,996  => ???:luaL_checkudata (7x)
 14    luaL_argcheck(L, childdata != 0, 2, "Node expected");
  .  
  7    std::shared_ptr<SceneNode> child(childdata->node);
  .  
  .    self->add_child(child);
  .  
  .    return 0;
 35  }
  .  
  .  // Set a node's material
  .  extern "C"
  .  int gr_node_set_material_cmd(lua_State* L)
 28  {
  .    GRLUA_DEBUG_CALL;
  .    
 35    gr_node_ud* selfdata = (gr_node_ud*)luaL_checkudata(L, 1, "gr.node");
2,996  => ???:luaL_checkudata (7x)
 14    luaL_argcheck(L, selfdata != 0, 1, "Node expected");
  .  
 67    GeometryNode* self = dynamic_cast<GeometryNode*>(selfdata->node);
1,150  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
1,036  => ???:__dynamic_cast (7x)
  .  
 14    luaL_argcheck(L, self != 0, 1, "Geometry node expected");
  .    
 42    gr_material_ud* matdata = (gr_material_ud*)luaL_checkudata(L, 2, "gr.material");
3,255  => ???:luaL_checkudata (7x)
 14    luaL_argcheck(L, matdata != 0, 2, "Material expected");
  .  
  .    self->set_material(matdata->material);
  .  
  .    return 0;
 35  }
  .  
  .  // Add a scaling transformation to a node.
  .  extern "C"
  .  int gr_node_scale_cmd(lua_State* L)
 35  {
  .    GRLUA_DEBUG_CALL;
  .    
 35    gr_node_ud* selfdata = (gr_node_ud*)luaL_checkudata(L, 1, "gr.node");
2,996  => ???:luaL_checkudata (7x)
 14    luaL_argcheck(L, selfdata != 0, 1, "Node expected");
  .  
 35    SceneNode* self = selfdata->node;
  .  
  .    double values[3];
  .    
 42    for (int i = 0; i < 3; i++) {
105      values[i] = luaL_checknumber(L, i + 2);
651  => ???:luaL_checknumber (21x)
  .    }
  .  
 21    self->scale(Vector3D(values[0], values[1], values[2]));
13,111  => /home/jnbmoffa/git/raytracer/src/scene.cpp:SceneNode::scale(FastMath::Vector<3ul, double> const&) (7x)
  .  
  .    return 0;
 42  }
  .  
  .  // Add a translation to a node.
  .  extern "C"
  .  int gr_node_translate_cmd(lua_State* L)
 45  {
  .    GRLUA_DEBUG_CALL;
  .    
 45    gr_node_ud* selfdata = (gr_node_ud*)luaL_checkudata(L, 1, "gr.node");
3,852  => ???:luaL_checkudata (9x)
 18    luaL_argcheck(L, selfdata != 0, 1, "Node expected");
  .  
 45    SceneNode* self = selfdata->node;
  .  
  .    double values[3];
  .    
 54    for (int i = 0; i < 3; i++) {
135      values[i] = luaL_checknumber(L, i + 2);
1,019  => ???:luaL_checknumber (27x)
  .    }
  .  
 27    self->translate(Vector3D(values[0], values[1], values[2]));
18,442  => /home/jnbmoffa/git/raytracer/src/scene.cpp:SceneNode::translate(FastMath::Vector<3ul, double> const&) (9x)
  .  
  .    return 0;
 54  }
  .  
  .  // Rotate a node.
  .  extern "C"
  .  int gr_node_rotate_cmd(lua_State* L)
 12  {
  .    GRLUA_DEBUG_CALL;
  .    
 15    gr_node_ud* selfdata = (gr_node_ud*)luaL_checkudata(L, 1, "gr.node");
1,284  => ???:luaL_checkudata (3x)
  6    luaL_argcheck(L, selfdata != 0, 1, "Node expected");
  .  
  3    SceneNode* self = selfdata->node;
  .  
 18    const char* axis_string = luaL_checkstring(L, 2);
120  => ???:luaL_checklstring (3x)
  .  
 19    luaL_argcheck(L, axis_string
1,532  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
 48  => /build/buildd/eglibc-2.19/string/../sysdeps/x86_64/strlen.S:strlen (3x)
  6                  && std::strlen(axis_string) == 1, 2, "Single character expected");
 16    char axis = std::tolower(axis_string[0]);
1,536  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
 30  => /build/buildd/eglibc-2.19/ctype/ctype.c:tolower (3x)
  .    
  9    luaL_argcheck(L, axis >= 'x' && axis <= 'z', 2, "Axis must be x, y or z");
  .    
 12    double angle = luaL_checknumber(L, 3);
 93  => ???:luaL_checknumber (3x)
  .  
  9    self->rotate(axis, angle);
13,440  => /home/jnbmoffa/git/raytracer/src/scene.cpp:SceneNode::rotate(char, double) (3x)
  .  
  .    return 0;
 15  }
  .  
  .  // Garbage collection function for lua.
  .  extern "C"
  .  int gr_node_gc_cmd(lua_State* L)
  .  {
  .    GRLUA_DEBUG_CALL;
  .    
  .    gr_node_ud* data = (gr_node_ud*)luaL_checkudata(L, 1, "gr.node");
-- line 714 ----------------------------------------
-- line 772 ----------------------------------------
  .    {"translate", gr_node_translate_cmd},
  .    {"render", gr_render_cmd},
  .    {0, 0}
  .  };
  .  
  .  // This function calls the lua interpreter to define the scene and
  .  // raytrace it as appropriate.
  .  bool run_lua(const std::string& filename)
  6  {
  .    GRLUA_DEBUG("Importing scene from " << filename);
  .    
  .    // Start a lua interpreter
  7    lua_State* L = lua_open();
31,314  => ???:luaL_newstate (1x)
669  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
  .  
  .    GRLUA_DEBUG("Loading base libraries");
  .    
  .    // Load some base library
  7    luaL_openlibs(L);
669  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
294,393  => ???:luaL_openlibs (1x)
  .  
  .  
  .    GRLUA_DEBUG("Setting up our functions");
  .  
  .    // Set up the metatable for gr.node
  8    luaL_newmetatable(L, "gr.node");
737  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
1,446  => ???:luaL_newmetatable (1x)
  8    lua_pushstring(L, "__index");
206  => ???:lua_pushstring (1x)
692  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
  8    lua_pushvalue(L, -2);
 20  => ???:lua_pushvalue (1x)
704  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
  8    lua_settable(L, -3);
821  => ???:lua_settable (1x)
654  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
  .  
  .    // Load the gr.node methods
 10    luaL_openlib(L, 0, grlib_node_methods, 0);
10,526  => ???:luaL_openlib (1x)
654  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
  .  
  .    // Load the gr functions
  6    luaL_openlib(L, "gr", grlib_functions, 0);
19,653  => ???:luaL_openlib (1x)
  .  
  .    GRLUA_DEBUG("Parsing the scene");
  .    // Now parse the actual scene
 20    if (luaL_loadfile(L, filename.c_str()) || lua_pcall(L, 0, 0, 0)) {
1,286  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (2x)
442,368  => ???:luaL_loadfile (1x)
76,752,413,390  => ???:lua_pcall (1x)
  .      std::cerr << "Error loading " << filename << ": " << lua_tostring(L, -1) << std::endl;
  .      return false;
  .    }
  .    GRLUA_DEBUG("Closing the interpreter");
  .    
  .    // Cleanup the material shared pointers
  .    for(auto ptr : materials)
  .    {
-- line 816 ----------------------------------------
-- line 821 ----------------------------------------
  .    {
  .      ptr->camera.~shared_ptr<LuaCamera>();
  .    }
  .  
  .    // Close the interpreter, free up any resources not needed
  .    lua_close(L);
  .  
  .    return true;
  2  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/x86_64-linux-gnu/bits/string3.h
--------------------------------------------------------------------------------
         Ir 

-- line 76 ----------------------------------------
          .  __NTH (memset (void *__dest, int __ch, size_t __len))
          .  {
          .    if (__builtin_constant_p (__len) && __len == 0
          .        && (!__builtin_constant_p (__ch) || __ch != 0))
          .      {
          .        __warn_memset_zero_len ();
          .        return __dest;
          .      }
821,342,584    return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
          .  }
          .  
          .  #ifdef __USE_BSD
          .  __fortify_function void
          .  __NTH (bcopy (const void *__src, void *__dest, size_t __len))
          .  {
          .    (void) __builtin___memmove_chk (__dest, __src, __len, __bos0 (__dest));
          .  }
-- line 92 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jnbmoffa/git/raytracer/src/photonmap.cpp
--------------------------------------------------------------------------------
  No information has been collected for /home/jnbmoffa/git/raytracer/src/photonmap.cpp

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jnbmoffa/git/raytracer/src/scene_lua.cpp
--------------------------------------------------------------------------------
  No information has been collected for /home/jnbmoffa/git/raytracer/src/scene_lua.cpp

--------------------------------------------------------------------------------
-- Auto-annotated source: algebra.cpp
--------------------------------------------------------------------------------
         Ir 

-- line 73 ----------------------------------------
          .    std::swap(a[r1][0], a[r2][0]);
          .    std::swap(a[r1][1], a[r2][1]);
          .    std::swap(a[r1][2], a[r2][2]);
          .    std::swap(a[r1][3], a[r2][3]);
          .  }
          .  
          .  static void dividerow(Matrix4x4& a, size_t r, double fac)
          .  {
199,585,104    a[r][0] /= fac;
199,585,104    a[r][1] /= fac;
199,585,104    a[r][2] /= fac;
232,849,288    a[r][3] /= fac;
          .  }
          .  
          .  static void submultrow(Matrix4x4& a, size_t dest, size_t src, double fac)
          .  {
997,925,520    a[dest][0] -= fac * a[src][0];
997,925,520    a[dest][1] -= fac * a[src][1];
997,925,520    a[dest][2] -= fac * a[src][2];
997,925,520    a[dest][3] -= fac * a[src][3];
          .  }
          .  
          .  /*
          .   * invertMatrix
          .   *
          .   * I lifted this code from the skeleton code of a raytracer assignment
          .   * from a different school.  I taught that course too, so I figured it
          .   * would be okay.
          .   */
          .  Matrix4x4 Matrix4x4::invert() const
 66,528,368  {
          .    /* The algorithm is plain old Gauss-Jordan elimination 
          .       with partial pivoting. */
          .  
          .    Matrix4x4 a(*this);
          .    Matrix4x4 ret;
          .  
          .    /* Loop over cols of a from left to right, 
          .       eliminating above and below diag */
          .  
          .    /* Find largest pivot in column j among rows j..3 */
 74,844,414    for(size_t j = 0; j < 4; ++j) { 
          .      size_t i1 = j; /* Row with largest pivot candidate */
474,014,622      for(size_t i = j + 1; i < 4; ++i) {
498,962,760        if(fabs(a[i][j]) > fabs(a[i1][j])) {
          .          i1 = i;
          .        }
          .      }
          .  
          .      /* Swap rows i1 and j in a and ret to put pivot on diagonal */
166,320,920      swaprows(a, i1, j);
698,547,864  => /home/jnbmoffa/git/raytracer/src/algebra.hpp:swaprows(Matrix4x4&, unsigned long, unsigned long) (33264184x)
133,056,736      swaprows(ret, i1, j);
698,547,864  => /home/jnbmoffa/git/raytracer/src/algebra.hpp:swaprows(Matrix4x4&, unsigned long, unsigned long) (33264184x)
          .  
          .      /* Scale row j to have a unit diagonal */
232,849,288      if(a[j][j] == 0.0) {
          .        // Theoretically throw an exception.
          .        return ret;
          .      }
          .  
          .      dividerow(ret, j, a[j][j]);
          .      dividerow(a, j, a[j][j]);
          .  
          .      /* Eliminate off-diagonal elems in col j of a, doing identical 
          .         ops to b */
731,812,048      for(size_t i = 0; i < 4; ++i) {
266,113,472        if(i != j) {
598,755,312          submultrow(ret, i, j, a[i][j]);
2,395,021,248  => /home/jnbmoffa/git/raytracer/src/algebra.hpp:submultrow(Matrix4x4&, unsigned long, unsigned long, double) (99792552x)
598,755,312          submultrow(a, i, j, a[i][j]);
2,395,021,248  => /home/jnbmoffa/git/raytracer/src/algebra.hpp:submultrow(Matrix4x4&, unsigned long, unsigned long, double) (99792552x)
          .        }
          .      }
          .    }
          .  
          .    return ret;
 74,844,417  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/4.9/bits/random.h
--------------------------------------------------------------------------------
         Ir 

-- line 132 ----------------------------------------
          .      // - for m == 2^n or m == 0, unsigned integer overflow is safe.
          .      // - a * (m - 1) + c fits in _Tp, there is no overflow.
          .      template<typename _Tp, _Tp __m, _Tp __a, _Tp __c, bool __s>
          .        struct _Mod<_Tp, __m, __a, __c, true, __s>
          .        {
          .  	static _Tp
          .  	__calc(_Tp __x)
          .  	{
 36,883,530  	  _Tp __res = __a * __x + __c;
          .  	  if (__m)
497,927,666  	    __res %= __m;
          .  	  return __res;
          .  	}
          .        };
          .  
          .      template<typename _Tp, _Tp __m, _Tp __a = 1, _Tp __c = 0>
          .        inline _Tp
          .        __mod(_Tp __x)
          .        { return _Mod<_Tp, __m, __a, __c>::__calc(__x); }
-- line 150 ----------------------------------------
-- line 184 ----------------------------------------
          .  	 * into a value in the input domain for the dependent random number
          .  	 * distribution.
          .  	 */
          .  	_DInputType
          .  	operator()()
          .  	{
          .  	  return std::generate_canonical<_DInputType,
          .  	                            std::numeric_limits<_DInputType>::digits,
 55,325,295  	                            _Engine>(_M_g);
811,437,660  => /usr/include/c++/4.9/bits/random.h:double std::generate_canonical<double, 53ul, std::linear_congruential_engine<unsigned long, 16807ul, 0ul, 2147483647ul> >(std::linear_congruential_engine<unsigned long, 16807ul, 0ul, 2147483647ul>&) (18441765x)
          .  	}
          .  
          .        private:
          .  	_Engine& _M_g;
          .        };
          .  
          .    _GLIBCXX_END_NAMESPACE_VERSION
          .    } // namespace __detail
-- line 200 ----------------------------------------
-- line 1582 ----------------------------------------
          .  
          .      // constructors, destructors and member functions
          .  
          .  #ifdef _GLIBCXX_USE_RANDOM_TR1
          .  
          .      explicit
          .      random_device(const std::string& __token = "default")
          .      {
          8        _M_init(__token);
      4,476  => ???:std::random_device::_M_init(std::string const&) (1x)
      1,482  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
          .      }
          .  
          .      ~random_device()
          7      { _M_fini(); }
      1,426  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
      2,158  => ???:std::random_device::_M_fini() (1x)
          .  
          .  #else
          .  
          .      explicit
          .      random_device(const std::string& __token = "mt19937")
          .      { _M_init_pretr1(__token); }
          .  
          .    public:
-- line 1602 ----------------------------------------
-- line 1614 ----------------------------------------
          .      double
          .      entropy() const noexcept
          .      { return 0.0; }
          .  
          .      result_type
          .      operator()()
          .      {
          .  #ifdef _GLIBCXX_USE_RANDOM_TR1
          7        return this->_M_getval();
      2,931  => ???:std::random_device::_M_getval() (1x)
      1,424  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
          .  #else
          .        return this->_M_getval_pretr1();
          .  #endif
          .      }
          .  
          .      // No copy functions.
          .      random_device(const random_device&) = delete;
          .      void operator=(const random_device&) = delete;
-- line 1630 ----------------------------------------
-- line 1877 ----------------------------------------
          .        /** Parameter type. */
          .        struct param_type
          .        {
          .  	typedef uniform_real_distribution<_RealType> distribution_type;
          .  
          .  	explicit
          .  	param_type(_RealType __a = _RealType(0),
          .  		   _RealType __b = _RealType(1))
          4  	: _M_a(__a), _M_b(__b)
          .  	{
          .  	  _GLIBCXX_DEBUG_ASSERT(_M_a <= _M_b);
          .  	}
          .  
          .  	result_type
          .  	a() const
          .  	{ return _M_a; }
          .  
-- line 1893 ----------------------------------------
-- line 1977 ----------------------------------------
          .  
          .        template<typename _UniformRandomNumberGenerator>
          .  	result_type
          .  	operator()(_UniformRandomNumberGenerator& __urng,
          .  		   const param_type& __p)
          .  	{
          .  	  __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
          .  	    __aurng(__urng);
 98,356,080  	  return (__aurng() * (__p.b() - __p.a())) + __p.a();
          .  	}
          .  
          .        template<typename _ForwardIterator,
          .  	       typename _UniformRandomNumberGenerator>
          .  	void
          .  	__generate(_ForwardIterator __f, _ForwardIterator __t,
          .  		   _UniformRandomNumberGenerator& __urng)
          .  	{ this->__generate(__f, __t, __urng, _M_param); }
-- line 1993 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: main.cpp
--------------------------------------------------------------------------------
Ir 

 .  #include <iostream>
 .  #include <unistd.h>
 .  #include "scene_lua.hpp"
 .  #include "render.hpp"
 .  
 .  int main(int argc, char** argv)
 5  {
 9    std::string filename = "scene.lua";
1,192  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
6,275  => ???:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (1x)
 2    if (argc >= 2) {
 .      filename = argv[1];
 .    }
 .  
 .    int c;
11    while ((c = getopt(argc, argv, ":t:s:oa")) != -1) {
741  => /build/buildd/eglibc-2.19/posix/getopt.c:getopt (1x)
1,513  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
 .      switch(c) {
 .      case 't': // number of render threads
 .        xDiv = yDiv = atoi(optarg);
 .        break;
 .      case 's': // supersampling
 .        SuperSamples = atoi(optarg);
 .        if (bUseAdaptive)
 .        {
-- line 22 ----------------------------------------
-- line 40 ----------------------------------------
 .            "Option -%c requires an operand\n", optopt);
 .        break;
 .      case '?':
 .        fprintf(stderr,
 .            "Unrecognized option: '-%c'\n", optopt);
 .      }
 .    }
 .  
 2    if (!run_lua(filename)) {
76,753,220,290  => /home/jnbmoffa/git/raytracer/src/scene_lua.cpp:run_lua(std::string const&) (1x)
 .      std::cerr << "Could not open " << filename << std::endl;
 .      return 1;
 .    }
 2  }

--------------------------------------------------------------------------------
-- Auto-annotated source: scenecontainer.cpp
--------------------------------------------------------------------------------
         Ir 

-- line 8 ----------------------------------------
          .    for (auto& S : *Nodes)
          .    {
          .      if(S->TimeTrace(R, closestDist, Hit, M, Time)) bHit = true;
          .    }
          .    return bHit;
          .  }
          .  
          .  bool SceneContainer::ContainerSpecificColourTrace(const Ray& R, HitInfo& Hit)
 45,619,868  {
 26,068,496    double closestDist = 10000000.f; Matrix4x4 M;
          .    bool bHit = false;
136,859,598    for (auto& S : *Nodes)
          .    {
593,058,259      if(S->ColourTrace(R, closestDist, Hit, M)) bHit = true;
70,358,823,264  => /home/jnbmoffa/git/raytracer/src/scene.cpp:GeometryNode::ColourTrace(Ray, double&, HitInfo&, Matrix4x4&) (45619866x)
          .    }
          .    return bHit;
 58,654,107  }
          .  
          .  bool SceneContainer::ContainerSpecificDepthTrace(const Ray& R, double& dist)
          .  {
          .    bool bHit = false;
          .    HitInfo ShadowHit; Matrix4x4 M;
          .    dist = 1000000.f;
          .    for (auto& S : *Nodes)
          .    {
-- line 32 ----------------------------------------
-- line 61 ----------------------------------------
          .      OutCol = Hit.Mat->DoLighting(this, R, lights, Hit, ambient, 0);
          .      return true;
          .    }
          .    return false;
          .  }
          .  
          .  bool SceneContainer::PhotonTrace(const Ray& R, HitInfo& Hit)
          .  {
 19,551,372    return ContainerSpecificColourTrace(R, Hit);
74,999,015,374  => scenecontainer.cpp:SceneContainer::ContainerSpecificColourTrace(Ray const&, HitInfo&) (6517124x)
          .  }
          .  
          .  bool SceneContainer::TimeDepthTrace(const Ray& R, double& dist, const double& Time)
          .  {
          .    HitInfo Hit;
          .    bool bHit = ContainerSpecificTimeTrace(R, Hit, Time);
          .    dist = (Hit.Location - R.Start).length();
          .    return bHit;
-- line 77 ----------------------------------------
-- line 125 ----------------------------------------
          .    dist = 1000000.f;
          .    Array<SceneNode*> OctList;
          .    Tree.Trace(OctList, R);
          .    for (SceneNode* S : OctList)
          .    {
          .      if(S->DepthTrace(R, dist, Hit, M)) bHit = true;
          .    }
          .    return bHit;
          2  }
--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/4.9/bits/stl_algobase.h
--------------------------------------------------------------------------------
           Ir 

-- line 193 ----------------------------------------
            .      inline const _Tp&
            .      min(const _Tp& __a, const _Tp& __b)
            .      {
            .        // concept requirements
            .        __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
            .        //return __b < __a ? __b : __a;
            .        if (__b < __a)
            .  	return __b;
    1,458,980        return __a;
            .      }
            .  
            .    /**
            .     *  @brief This does what you think it does.
            .     *  @ingroup sorting_algorithms
            .     *  @param  __a  A thing of arbitrary type.
            .     *  @param  __b  Another thing of arbitrary type.
            .     *  @return   The greater of the parameters.
-- line 209 ----------------------------------------
-- line 214 ----------------------------------------
            .    */
            .    template<typename _Tp>
            .      inline const _Tp&
            .      max(const _Tp& __a, const _Tp& __b)
            .      {
            .        // concept requirements
            .        __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
            .        //return  __a < __b ? __b : __a;
           22        if (__a < __b)
            .  	return __b;
            .        return __a;
            .      }
            .  
            .    /**
            .     *  @brief This does what you think it does.
            .     *  @ingroup sorting_algorithms
            .     *  @param  __a  A thing of arbitrary type.
-- line 230 ----------------------------------------
-- line 368 ----------------------------------------
            .          static _Tp*
            .          __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
            .          {
            .  #if __cplusplus >= 201103L
            .  	  // trivial types can have deleted assignment
            .  	  static_assert( is_copy_assignable<_Tp>::value,
            .  	                 "type is not assignable" );
            .  #endif
  319,339,100  	  const ptrdiff_t _Num = __last - __first;
  430,130,194  	  if (_Num)
8,167,409,782  	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
    1,479,472  => /build/buildd/eglibc-2.19/string/../sysdeps/x86_64/multiarch/memcpy-sse2-unaligned.S:__memcpy_sse2_unaligned (92467x)
            .  	  return __result + _Num;
            .  	}
            .      };
            .  
            .    template<bool _IsMove, typename _II, typename _OI>
            .      inline _OI
            .      __copy_move_a(_II __first, _II __last, _OI __result)
            .      {
-- line 386 ----------------------------------------
-- line 695 ----------------------------------------
            .      
            .    template<typename _ForwardIterator, typename _Tp>
            .      inline typename
            .      __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
            .      __fill_a(_ForwardIterator __first, _ForwardIterator __last,
            .  	     const _Tp& __value)
            .      {
            .        const _Tp __tmp = __value;
3,735,940,878        for (; __first != __last; ++__first)
  967,249,488  	*__first = __tmp;
            .      }
            .  
            .    // Specialization: for char types we can use memset.
            .    template<typename _Tp>
            .      inline typename
            .      __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
            .      __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
            .      {
-- line 712 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: scenecontainer.h
--------------------------------------------------------------------------------
Ir 

-- line 18 ----------------------------------------
 .  	PhotonMap PMap;
 .  	virtual bool ContainerSpecificTimeTrace(const Ray& R, HitInfo& Hit, const double& Time);
 .  	virtual bool ContainerSpecificColourTrace(const Ray& R, HitInfo& Hit);
 .  	virtual bool ContainerSpecificDepthTrace(const Ray& R, double& dist);
 .  
 .  public:
 .  	const std::list<std::unique_ptr<Light>>* lights;
 .  	virtual ~SceneContainer() {}
 9  	SceneContainer(std::vector<std::unique_ptr<SceneNode>>* Nodes, const std::list<std::unique_ptr<Light>>* lights, unsigned int Photons) : Nodes(Nodes), PMap(this, Photons), lights(lights) 
15,672  => /home/jnbmoffa/git/raytracer/src/photonmap.cpp:PhotonMap::PhotonMap(SceneContainer*, unsigned long) (1x)
 .  	{
 .  		// Map photons
 2    		PMap.BuildTree();
76,752,182,986  => /home/jnbmoffa/git/raytracer/src/photonmap.cpp:PhotonMap::BuildTree() (1x)
 .  	}
 .  
 .  	// Find all photons within SearchDistSq square units from the CheckLoc
 .  	// MaxDist2 will be the square dist to the furthest away photon returned
 .  	void LocatePhotons(Array<Photon*>& OutArray, const Point3D& CheckLoc, const double& SearchDistSq, double& MaxDist2);
 .  
 .  	inline unsigned int MappedPhotons() { return PMap.NumPhotons(); }
 .  
-- line 37 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: fastmath.h
--------------------------------------------------------------------------------
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ Source file 'fastmath.h' is more recent than input file 'callgrind.out.8921'.
@ Annotations may not be correct.
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

            Ir 

-- line 15 ----------------------------------------
             .    // ### Useful TMP Functions
             .    // ################################################################
             .  
             .    // Multiply all elements of the object by a value
             .    template<class Type, int N>
             .    struct MultElements
             .    {
             .      static inline void eval(Type& obj, const typename Type::value_type& mult)
   399,393,891      {
             .        obj[N] *= mult;
             .        MultElements<Type,N-1>::eval(obj,mult);
             .      }
             .    };
             .  
             .    // Multiply and add the two arrays like so:
             .    //    a[0]*b[0] + a[1]*b[1] + ...
             .    template<class Type, size_t N, size_t I>
             .    struct MultArrays
             .    {
             .      static_assert(N > 0, "Array must have size > 0");
             .      static inline Type eval(const Type (&a)[N], const Type (&b)[N])
             .      {
 3,323,302,155        return a[I]*b[I] + MultArrays<Type,N,I+1>::eval(a,b);
             .      }
             .    };
             .    // Specialize for 4D, 3D and 2D
             .    template<> struct MultArrays<double,4,4> {
             .      static inline double eval(const double (&)[4], const double (&)[4])
             .      { return 0.0; }
             .    };
             .    template<> struct MultArrays<double,3,3> {
-- line 45 ----------------------------------------
-- line 86 ----------------------------------------
             .  
             .      Point()
             .      {
             .        std::memset(v_,0,sizeof(value_type)*N);
             .      }
             .      Point(const point_type& other)
             .      {
             .        std::copy(other.v_, other.v_+N, v_);
    12,294,510      }
             .      
             .      // Creates a ctor that takes N elements to initialize v_ with
             .      // i,e: Point3D(double x, double y, double z){ ... }
             .      // static_asserts are used to enforce the correct number of arguments
             .      template<typename... Args>
             .      explicit Point(const value_type& x, Args&&... args)
             .      {
             .        v_[0] = x;
    90,624,906        ctorHelper(std::forward<decltype(args)>(args)...);
             .      }
             .      template<size_t Idx = 1,typename... Args>
             .      void ctorHelper(const value_type& x, Args&&... args)
             .      {
             .        static_assert(Idx < N, "Too many args passed to Point constructor");
             .        v_[Idx] = x;
   116,078,574        ctorHelper<Idx+1>(std::forward<decltype(args)>(args)...);
             .      }
             .      template<size_t Idx>
             .      void ctorHelper()
             .      {
             .        static_assert(Idx == N, "Too few args passed to Point constructor");
             .      }
             .  
             .      point_type& operator =(const point_type& other)
-- line 118 ----------------------------------------
-- line 123 ----------------------------------------
             .  
             .      value_type& operator[](size_t idx) 
             .      {
             .        return v_[ idx ];
             .      }
             .      value_type operator[](size_t idx) const 
             .      {
             .        return v_[ idx ];
   432,008,208      }
             .  
             .    private:
             .      value_type v_[N];
             .    };
             .  
             .    using Point3D = Point<3,double>;
             .  
             .    // ################################################################
-- line 139 ----------------------------------------
-- line 148 ----------------------------------------
             .  
             .      Vector()
             .      {
             .        std::memset(v_,0,sizeof(value_type)*N);
             .      }
             .      Vector(const vec_type& other)
             .      {
             .        std::copy(other.v_, other.v_+N, v_);
    45,712,340      }
             .  
             .      // Creates a ctor that takes N elements to initialize v_ with
             .      // i,e: Vector4D(double x, double y, double z, double w){ ... }
             .      // static_asserts are used to enforce the correct number of arguments
             .      template<typename... Args>
             .      explicit Vector(const value_type& x, Args&&... args)
             .      {
             .        v_[0] = x;
   124,497,402        ctorHelper(std::forward<decltype(args)>(args)...);
             .      }
             .      template<size_t Idx = 1,typename... Args>
             .      void ctorHelper(const value_type& x, Args&&... args)
             .      {
             .        static_assert(Idx < N, "Too many args passed to Vector constructor");
             .        v_[Idx] = x;
   358,544,450        ctorHelper<Idx+1>(std::forward<decltype(args)>(args)...);
             .      }
             .      template<size_t Idx>
             .      void ctorHelper()
             .      {
             .        static_assert(Idx == N, "Too few args passed to Vector constructor");
             .      }
             .  
             .      inline vec_type& operator =(const vec_type& other)
             .      {
             .        std::copy(other.v_, other.v_+N, v_);
    99,278,350        return *this;
             .      }
             .  
             .      inline value_type& operator[](size_t idx)
             .      {
             .        return v_[idx];
             .      }
             .      inline value_type operator[](size_t idx) const
             .      {
             .        return v_[idx];
   162,331,541      }
             .  
             .      value_type dot(const vec_type& other) const
             .      {
             .        return MultArrays<value_type,N,0>::eval(v_,other.v_);
             .      }
             .      value_type length2() const
             .      {
             .        return MultArrays<value_type,N,0>::eval(v_,v_);
             .      }
             .      value_type length() const
             .      {
             .        return sqrt(length2());
   241,292,350      }
             .      value_type normalize()
             .      {
             .        if(length2() > 0.0)
   104,273,980        {
             .          value_type invlen = 1.0/length();
   169,630,155          MultElements<vec_type,N-1>::eval(*this,invlen);
             .          return invlen;
             .        }
             .        return 0.0;
             .      }
             .  
             .    private:
             .      value_type v_[N];
             .    };
-- line 220 ----------------------------------------
-- line 230 ----------------------------------------
             .    template<> struct MultElements<Vector4D,-1>
             .    {
             .      static inline void eval(Vector4D&, const typename Vector4D::value_type&){}
             .    };
             .  
             .    inline Vector3D operator *(double s, const Vector3D& v)
             .    {
             .      return Vector3D(s*v[0], s*v[1], s*v[2]);
   339,038,586    }
             .  
             .    inline Vector3D operator +(const Vector3D& a, const Vector3D& b)
             .    {
             .      return Vector3D(a[0]+b[0], a[1]+b[1], a[2]+b[2]);
   393,017,957    }
             .  
             .    inline Point3D operator +(const Point3D& a, const Vector3D& b)
             .    {
             .      return Point3D(a[0]+b[0], a[1]+b[1], a[2]+b[2]);
   589,465,014    }
             .  
             .    inline Point3D operator +(const Point3D& a, const Point3D& b)
             .    {
             .      return Point3D(a[0]+b[0], a[1]+b[1], a[2]+b[2]);
   162,928,095    }
             .  
             .    inline Vector3D operator -(const Point3D& a, const Point3D& b)
             .    {
             .      return Vector3D(a[0]-b[0], a[1]-b[1], a[2]-b[2]);
   118,699,650    }
             .  
             .    inline Vector3D operator -(const Vector3D& a, const Vector3D& b)
             .    {
             .      return Vector3D(a[0]-b[0], a[1]-b[1], a[2]-b[2]);
    39,626,580    }
             .  
             .    inline Vector3D operator -(const Vector3D& a)
             .    {
             .      return Vector3D(-a[0], -a[1], -a[2]);
     1,756,876    }
             .  
             .    inline Point3D operator -(const Point3D& a, const Vector3D& b)
             .    {
             .      return Point3D(a[0]-b[0], a[1]-b[1], a[2]-b[2]);
             .    }
             .  
             .    // Cross product specific to 3D vectors
             .    inline Vector3D cross(const Vector3D& a, const Vector3D& b)
-- line 276 ----------------------------------------
-- line 304 ----------------------------------------
             .    template<class Mtx, size_t I>
             .    struct MultMtxRowCol
             .    {
             .      enum : size_t { NxtI = I + 1  /* Counter */ };
             .      static inline auto eval(const Mtx& a, const Mtx& b,
             .        const size_t& R, const size_t& C)
             .      {
             .        return a[R][I] * b[I][C] + MultMtxRowCol<Mtx,NxtI>::eval(a,b,R,C);
10,948,775,760      }
             .    };
             .  
             .    // Multiplication of matricies
             .    // Must specialize this class to terminate for each type of matrix
             .    template<class Mtx, size_t N, size_t C, size_t R, size_t I>
             .    struct MultMtxImpl
             .    {
             .      enum : size_t
-- line 320 ----------------------------------------
-- line 321 ----------------------------------------
             .      {
             .        NxtI = I + 1,          // Counter
             .        NxtC = NxtI % N,       // Column
             .        NxtR = NxtI / N % N    // Row
             .      };
             .      static inline void eval(Mtx& ret, const Mtx& a, const Mtx& b)
             .      {
             .        ret[R][C] = MultMtxRowCol<Mtx,0>::eval(a,b,R,C);
   775,538,283        MultMtxImpl<Mtx,N,NxtC,NxtR,NxtI>::eval(ret,a,b);
             .      }
             .    };
             .  
             .    template<class Mtx, size_t N>
             .    struct MultMtx
             .    {
             .      static inline void eval( Mtx& ret, const Mtx& a, const Mtx& b )
             .      {
             .        MultMtxImpl< Mtx, N, 0, 0, 0 >::eval( ret, a, b );
   136,859,716      }
         2,313  => fastmath.h:FastMath::MultMtxImpl<Matrix4x4, 4ul, 0ul, 0ul, 0ul>::eval(Matrix4x4&, Matrix4x4 const&, Matrix4x4 const&) (9x)
             .    };
             .  
             .  
             .  
             .    // ################################################################
             .    // ### Factorial
             .    // ################################################################
             .  
-- line 347 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jnbmoffa/git/raytracer/src/scenecontainer.cpp
--------------------------------------------------------------------------------
  No information has been collected for /home/jnbmoffa/git/raytracer/src/scenecontainer.cpp

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jnbmoffa/git/raytracer/src/algebra.hpp
--------------------------------------------------------------------------------
  No information has been collected for /home/jnbmoffa/git/raytracer/src/algebra.hpp

--------------------------------------------------------------------------------
-- Auto-annotated source: scene.cpp
--------------------------------------------------------------------------------
         Ir 

          .  #include "scene.hpp"
          .  #include <iostream>
          .  
         75  SceneNode::SceneNode(const std::string& name, Matrix4x4 M)
          .    : m_name(name),
         64      m_trans(M)
        270  => ???:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string const&) (15x)
      1,142  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
          .  {
         60  }
          .  
          .  bool SceneNode::SimpleTrace(Ray R)
          .  {
          .    R.Transform(m_invtrans);
          .  
          .    for (auto iter = m_children.begin(); iter != m_children.end(); ++iter)
          .    {
          .      auto& Node = *iter;
-- line 16 ----------------------------------------
-- line 50 ----------------------------------------
          .  
          .  bool SceneNode::TimeTrace(Ray R, double& closestDist, HitInfo& Hit, Matrix4x4& M, const double& Time)
          .  {
          .    (void)R; (void)closestDist; (void)Hit; (void)M; (void)Time;
          .    return false;
          .  }
          .  
          .  void SceneNode::FlattenScene(std::vector<std::unique_ptr<SceneNode>>& List, Matrix4x4 M)
         12  {
         24    for (auto& s : m_children)
          .    {
         56      s->FlattenScene(List, M * m_trans);
     18,198  => scene.cpp:GeometryNode::FlattenScene(std::vector<std::unique_ptr<SceneNode, std::default_delete<SceneNode> >, std::allocator<std::unique_ptr<SceneNode, std::default_delete<SceneNode> > > >&, Matrix4x4) (7x)
          .    }
          8  }
          .  
          .  void SceneNode::rotate(char axis, double angle)
         24  {
          .    //std::cerr << "Stub: Rotate " << m_name << " around " << axis << " by " << angle << std::endl;
          3    m_trans.rotate(axis, angle);
          9    m_invtrans = m_trans.invert();
      4,287  => /home/jnbmoffa/git/raytracer/src/algebra.cpp:Matrix4x4::invert() const (3x)
         26  }
      2,928  => /build/buildd/eglibc-2.19/math/../sysdeps/ieee754/dbl-64/s_sincos.c:sincos (2x)
      1,135  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
          .  
          .  void SceneNode::scale(const Vector3D& amount)
         28  {
          .    //std::cerr << "Stub: Scale " << m_name << " by " << amount << std::endl;
          7    m_trans.scale(amount);
         21    m_invtrans = m_trans.invert();
     10,003  => /home/jnbmoffa/git/raytracer/src/algebra.cpp:Matrix4x4::invert() const (7x)
         28  }
          .  
          .  void SceneNode::translate(const Vector3D& amount)
         36  {
          .    //std::cerr << "Stub: Translate " << m_name << " by " << amount << std::endl;
          9    m_trans.translate(amount);
         27    m_invtrans = m_trans.invert();
     14,446  => /home/jnbmoffa/git/raytracer/src/algebra.cpp:Matrix4x4::invert() const (9x)
         36  }
          .  
          .  bool SceneNode::is_joint() const
          .  {
          .    return false;
          .  }
          .  
          .  JointNode::JointNode(const std::string& name)
          .    : SceneNode(name)
-- line 92 ----------------------------------------
-- line 107 ----------------------------------------
          .  
          .  void JointNode::set_joint_y(double min, double init, double max)
          .  {
          .    m_joint_y.min = min;
          .    m_joint_y.init = init;
          .    m_joint_y.max = max;
          .  }
          .  
         63  GeometryNode::GeometryNode(const std::string& name, std::shared_ptr<Primitive> primitive, Vector3D Velocity)
          .    : SceneNode(name),
          .      Velocity(Velocity),
         35      m_primitive(primitive)
        966  => scene.cpp:SceneNode::SceneNode(std::string const&, Matrix4x4) (7x)
          .  {
         35  }
          .  
         77  GeometryNode::GeometryNode(const std::string& name, std::shared_ptr<Primitive> primitive, std::shared_ptr<Material>& Mat, Matrix4x4 M, Vector3D Velocity)
          .    : SceneNode(name, M),
          .      Velocity(Velocity),
          .      m_material(Mat),
         42      m_primitive(primitive)
        966  => scene.cpp:SceneNode::SceneNode(std::string const&, Matrix4x4) (7x)
          .  {
         21    m_invtrans = m_trans.invert();
     10,003  => /home/jnbmoffa/git/raytracer/src/algebra.cpp:Matrix4x4::invert() const (7x)
         49  }
          .  
          .  void GeometryNode::FlattenScene(std::vector<std::unique_ptr<SceneNode>>& List, Matrix4x4 M)
         70  {
         28    List.emplace_back(std::make_unique<GeometryNode>(m_name, m_primitive, m_material, M * m_trans, Velocity));
         56  }
          .  
          .  bool GeometryNode::SimpleTrace(Ray R)
          .  {
          .    if (m_primitive->SimpleTrace(R)) return true;
          .    return false;
          .  }
          .  
          .  bool GeometryNode::DepthTrace(Ray R, double& closestDist, HitInfo& Hit, Matrix4x4& M)
-- line 142 ----------------------------------------
-- line 147 ----------------------------------------
          .    if (m_primitive->DepthTrace(R, closestDist, Hit, M * m_trans))
          .    {
          .      ret = true;
          .    }
          .    return ret;
          .  }
          .  
          .  bool GeometryNode::ColourTrace(Ray R, double& closestDist, HitInfo& Hit, Matrix4x4& M)
501,818,526  {
          .    R.Transform(m_invtrans);
          .  
644,804,662    if (m_primitive->DepthTrace(R, closestDist, Hit, M * m_trans))
44,035,350,681  => /home/jnbmoffa/git/raytracer/src/primitive.cpp:Cube::DepthTrace(Ray, double&, HitInfo&, Matrix4x4 const&) (32585620x)
1,579,125,601  => /home/jnbmoffa/git/raytracer/src/primitive.cpp:Sphere::DepthTrace(Ray, double&, HitInfo&, Matrix4x4 const&) (13034246x)
          .    {
  6,126,540      Hit.Mat = m_material.get();
  6,126,540      return true;
          .    }
136,859,598    return false;
364,958,920  }
          .  
          .  bool GeometryNode::TimeTrace(Ray R, double& closestDist, HitInfo& Hit, Matrix4x4& M, const double& Time)
          .  {
          .    Matrix4x4 m_timetrans = M * m_trans;
          .    if (Velocity != Vector3D())
          .    {
          .      m_timetrans.translate(Time*Velocity);
          .      R.Transform(m_timetrans.invert());
-- line 172 ----------------------------------------
-- line 202 ----------------------------------------
          .      Bounds.GetLeft() = std::min(Bounds.GetLeft(), B.GetLeft());
          .      Bounds.GetRight() = std::max(Bounds.GetRight(), B.GetRight());
          .      Bounds.GetTop() = std::max(Bounds.GetTop(), B.GetTop());
          .      Bounds.GetBottom() = std::min(Bounds.GetBottom(), B.GetBottom());
          .      Bounds.GetFront() = std::max(Bounds.GetFront(), B.GetFront());
          .      Bounds.GetBack() = std::min(Bounds.GetBack(), B.GetBack());
          .    }
          .    return Bounds;
          2  }
--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jnbmoffa/git/raytracer/src/primitive.cpp
--------------------------------------------------------------------------------
  No information has been collected for /home/jnbmoffa/git/raytracer/src/primitive.cpp

--------------------------------------------------------------------------------
-- Auto-annotated source: primitive.hpp
--------------------------------------------------------------------------------
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ Source file 'primitive.hpp' is more recent than input file 'callgrind.out.8921'.
@ Annotations may not be correct.
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

           Ir 

-- line 12 ----------------------------------------
            .    virtual bool SimpleTrace(Ray R) { return Bounds.Intersects(R); }
            .    virtual bool DepthTrace(Ray R, double& closestDist, HitInfo& Hit, const Matrix4x4& M)
            .      { (void)R; (void)closestDist; (void)M; (void)Hit; return false; }
            .    inline BoxF GetBox() { return Bounds; }
            .  };
            .  
            .  class Sphere : public Primitive {
            .  public:
            6    Sphere() : m_center(0, 0, 0), m_radius(1) { Bounds = BoxF(-1, 1, 1, -1, 1, -1); }
            .    Sphere(const Point3D& C, double R) : m_center(C), m_radius(R) 
            .    {
            .      Bounds = BoxF(m_center[0]-m_radius, m_center[0]+m_radius, m_center[1]+m_radius, m_center[1]-m_radius, m_center[2]+m_radius, m_center[2]-m_radius); 
            .    }
            .    virtual ~Sphere();
            .  
            .    virtual bool SimpleTrace(Ray R);
            .    virtual bool DepthTrace(Ray R, double& closestDist, HitInfo& Hit, const Matrix4x4& M);
            .  private:
            .    Point3D m_center;
            .    double m_radius;
            .  };
            .  
            .  class Cube : public Primitive {
            .  public:
           15    Cube() : m_pos(0,0,0), m_size(1.f) { Bounds = BoxF(0, 1, 1, 0, 1, 0); }
            .    virtual ~Cube();
            .    bool IsInside(Point3D Int, Vector3D Mask);
            .    virtual bool DepthTrace(Ray R, double& closestDist, HitInfo& Hit, const Matrix4x4& M);
            .  
            .  private:
            .    Point3D m_pos;
            .    double m_size;
            .  };
-- line 44 ----------------------------------------
-- line 96 ----------------------------------------
            .  private:
            .    Point3D m_pos;
            .    double m_size;
            .  };
            .  
            .  inline bool clampDist(double& closestDist, const Point3D& WorldRay, const Point3D& WorldHit, const Vector3D& Normal, HitInfo& Hit, const Matrix4x4& M)
            .  {
            .    double Dist = (WorldHit - WorldRay).length();
   66,864,492    if (closestDist > Dist && Dist > EPSILON)
            .    {
    8,316,020      closestDist = Dist;
            .      Hit.Location = WorldHit;
            .      Hit.Normal = Normal;
   40,747,894      Hit.Normal = transNorm(M.invert(), Hit.Normal);
11,487,185,122  => /home/jnbmoffa/git/raytracer/src/algebra.cpp:Matrix4x4::invert() const (8038618x)
            .      return true;
            .    }
            .    return false;
            .  }
            .  
            .  bool CheckCloseHit(const Point3D& WorldRay, const Point3D& WorldHit);
            .  
            .  inline double SolveForD(Point3D P, Vector3D N)
            .  {
4,692,329,148    return -P[0]*N[0] - P[1]*N[1] - P[2]*N[2];
            .  }
            .  
            .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: photonmap.cpp
--------------------------------------------------------------------------------
        Ir 

         .  #include "photonmap.hpp"
         .  #include "scenecontainer.h"
         .  #include "light.hpp"
         .  #include "material.hpp"
         .  #include <iostream>
         .  #include "progressthread.h"
         .  
         9  PhotonMap::PhotonMap(SceneContainer* Scene, size_type NumToEmit) : Scene(Scene), Tree(3), NumToEmit(NumToEmit), generator(std::random_device{}()),
       231  => ???:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (1x)
         3  	PhotonDistribution(-1.f,1.f)
         4  	{}
         .  
         .  PhotonMap::~PhotonMap()
         .  {
         .  	for (Photon* P : Storage)
         .  	{
         .  		if (P) delete P;
         .  	}
         .  }
         .  
         .  // Only does caustics
         .  void PhotonMap::TracePhoton(const Ray& R, const Colour& Power, unsigned int depth, bool bHasRef)
58,654,116  {
13,034,248  	if (depth >= 9) return;
         .  
         .  	HitInfo Hit;
45,619,866  	if (!Scene->PhotonTrace(R, Hit)) return;
70,029,670,291  => /home/jnbmoffa/git/raytracer/src/scenecontainer.cpp:SceneContainer::PhotonTrace(Ray const&, HitInfo&) (6147255x)
         .  
         .  	// Refraction enabled?
40,519,339  	if (Hit.Mat->GetRef())
10,837,218  => /home/jnbmoffa/git/raytracer/src/material.hpp:PhongMaterial::GetRef() (5418609x)
         .  	{
   277,402  		unsigned int nextDepth = depth+1;
         .  		double NdotR = R.Direction.dot(Hit.Normal);
         .  		double ni, nt;
   832,206  		if (NdotR > 0)
         .  		{
         .  			// Leaving object
 1,664,406  			ni = Hit.Mat->GetRefIndex(); nt = 1.f;
   369,868  => /home/jnbmoffa/git/raytracer/src/material.hpp:PhongMaterial::GetRefIndex() (184934x)
         .  			Hit.Normal = -Hit.Normal;
         .  		}
         .  		else
         .  		{
         .  			// Entering object
   832,212  			ni = 1.f; nt = Hit.Mat->GetRefIndex();
   184,936  => /home/jnbmoffa/git/raytracer/src/material.hpp:PhongMaterial::GetRefIndex() (92468x)
         .  			NdotR = (-R.Direction).dot(Hit.Normal);
         .  		}
 2,774,020  		double sin2t = (ni/nt)*(ni/nt)*(1.f-NdotR*NdotR); // assumes R.Direction and Hit.Normal are normalized
         .  
   554,804  		if (sin2t <= 1.f)
         .  		{
         .  			// Fresnel
   647,276  			double cost = sqrt(1.f-sin2t);
   832,212  			double R1 = (ni*NdotR - nt*cost)/(ni*NdotR + nt*cost); R1 *= R1;
   647,276  			double R2 = (nt*NdotR - ni*cost)/(nt*NdotR + ni*cost); R2 *= R2;
   184,936  			double Reflectance = (R1 + R2)/2.f;
         .  
         .  			// Photons don't do glossy reflection
         .  			Ray ReflectedRay = R.Reflect(Hit, NdotR);
 1,109,616  			TracePhoton(ReflectedRay, Reflectance*Power, nextDepth, bHasRef);
2,511,184,399  => photonmap.cpp:PhotonMap::TracePhoton(Ray const&, Colour const&, unsigned int, bool)'2 (92468x)
         .  
         .  			Ray RefractedRay = R.Refract(ni, nt, NdotR, sin2t, Hit);
   832,203  			TracePhoton(RefractedRay, (1.f-Reflectance)*Power, nextDepth, true);
2,538,101,014  => photonmap.cpp:PhotonMap::TracePhoton(Ray const&, Colour const&, unsigned int, bool)'2 (92467x)
         .  		}
         .  		else
         .  		{
         .  			// Total internal reflection
         .  			Ray ReflectedRay = R.Reflect(Hit, NdotR);
 1,294,538  			TracePhoton(ReflectedRay, Power, nextDepth, bHasRef);
2,380,970,782  => photonmap.cpp:PhotonMap::TracePhoton(Ray const&, Colour const&, unsigned int, bool)'2 (184934x)
         .  		}
         .  	}
11,022,150  	else if (bHasRef)
         .  	{
         .  		// Stick if this trace has refracted at least once
   369,868  		Storage.emplace_back(new Photon(Hit.Location, Power, R.Direction));
19,148,653  => ???:operator new(unsigned long) (92467x)
         .  	}
45,619,854  }
         .  
         .  void PhotonMap::BuildTree()
         7  {
         3  	if (NumToEmit > 0)
         .  	{
         3  		std::cout << "Mapping " << NumToEmit * Scene->lights->size() << " photons..." << std::endl;
        10  		std::unique_ptr<ProgressThread> Status(CreateThread<ProgressThread>((double)NumToEmit * Scene->lights->size()));
         7  		Storage.reserve(NumToEmit * Scene->lights->size());
         4  		for (auto& L : *(Scene->lights))
         .  		{
         7  			Colour Power = (L->power * L->colour) / NumToEmit;
18,441,766  			for (size_type n=0;n<NumToEmit;n++)
         .  			{
         .  				// Random photon directions
         .  				Vector3D Dir(PhotonDistribution(generator), PhotonDistribution(generator), PhotonDistribution(generator)); Dir.normalize();
36,883,530  				TracePhoton(Ray(L->position, Dir), Power, 0);
75,356,725,049  => photonmap.cpp:PhotonMap::TracePhoton(Ray const&, Colour const&, unsigned int, bool) (6147255x)
         .  				Status->PROGRESS++;
         .  			}
         .  		}
         .  
         .  		Tree.MakeTree(Storage);
         .  	}
         .  }
         .  
         .  void PhotonMap::LocatePhotons(Array<Photon*>& OutArray, const Point3D& CheckLoc, const double& SearchDistSq, double& MaxDist2)
         .  {
         .  	Photon P(CheckLoc, Colour(), Vector3D());
         .  	Tree.LocateNearby(OutArray, P, SearchDistSq, MaxDist2);
         2  }
--------------------------------------------------------------------------------
-- Auto-annotated source: algebra.hpp
--------------------------------------------------------------------------------
           Ir 

-- line 253 ----------------------------------------
            .  class Matrix4x4
            .  {
            .  public:
            .    using value_type = double;
            .  
            .    Matrix4x4()
            .    {
            .      // Construct an identity matrix
   24,948,183      std::fill(v_, v_+16, 0.0);
  154,170,370      v_[0] = 1.0;
   68,769,139      v_[5] = 1.0;
   60,453,093      v_[10] = 1.0;
   68,769,139      v_[15] = 1.0;
            .    }
            .    Matrix4x4(const Matrix4x4& other)
            .    {
            .      std::copy(other.v_, other.v_+16, v_);
            .    }
            .    Matrix4x4(const Vector4D row1, const Vector4D row2, const Vector4D row3, 
            .               const Vector4D row4)
            .    {
           35      v_[0] = row1[0]; 
           19      v_[1] = row1[1]; 
           19      v_[2] = row1[2]; 
           19      v_[3] = row1[3]; 
            .  
           19      v_[4] = row2[0]; 
           19      v_[5] = row2[1]; 
           19      v_[6] = row2[2]; 
           19      v_[7] = row2[3]; 
            .  
           19      v_[8] = row3[0]; 
           19      v_[9] = row3[1]; 
           19      v_[10] = row3[2]; 
           19      v_[11] = row3[3]; 
            .  
           19      v_[12] = row4[0]; 
           19      v_[13] = row4[1]; 
           26      v_[14] = row4[2]; 
           60      v_[15] = row4[3]; 
            .    }
            .    Matrix4x4(value_type *vals)
            .    {
            .      std::copy(vals, vals + 16, (value_type*)v_);
            .    }
            .  
            .    Matrix4x4& operator=(const Matrix4x4& other)
            .    {
-- line 300 ----------------------------------------
-- line 303 ----------------------------------------
            .    }
            .  
            .    Vector4D getRow(size_t row) const
            .    {
            .      return Vector4D(v_[4*row], v_[4*row+1], v_[4*row+2], v_[4*row+3]);
            .    }
            .    value_type *getRow(size_t row) 
            .    {
1,064,453,888      return (value_type*)v_ + 4*row;
            .    }
            .  
            .    Vector4D getColumn(size_t col) const
            .    {
            .      return Vector4D(v_[col], v_[4+col], v_[8+col], v_[12+col]);
            .    }
            .  
            .    Vector4D operator[](size_t row) const
-- line 319 ----------------------------------------
-- line 322 ----------------------------------------
            .    }
            .    value_type *operator[](size_t row) 
            .    {
            .      return getRow(row);
            .    }
            .  
            .    void rotate(char axis, value_type angle)
            .    {
           24      value_type rad = angle * (M_PI/180);
            .      Vector4D R1(1.f, 0.f, 0.f, 0.f),
            .               R2(0.f, 1.f, 0.f, 0.f),
            .               R3(0.f, 0.f, 1.f, 0.f),
            .               R4(0.f, 0.f, 0.f, 1.f);
            .      switch (axis)
            .      {
            .        case 'x':
            .        case 'X':
           21          R2 = Vector4D(0.f, cos(rad), -sin(rad), 0.f);
        1,336  => /build/buildd/eglibc-2.19/math/../sysdeps/ieee754/dbl-64/s_sin.c:__cos_avx (1x)
        2,226  => /build/buildd/eglibc-2.19/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (2x)
          103  => /build/buildd/eglibc-2.19/math/../sysdeps/ieee754/dbl-64/s_sin.c:__sin_avx (1x)
            .          R3 = Vector4D(0.f, sin(rad), cos(rad), 0.f);
            .          break;
            .        case 'y':
            .        case 'Y':
            .          R1 = Vector4D(cos(rad), 0.f, sin(rad), 0.f);
            .          R3 = Vector4D(-sin(rad), 0.f, cos(rad), 0.f);
            .          break;
            .        case 'z':
            .        case 'Z':
            6          R1 = Vector4D(cos(rad), -sin(rad), 0.f, 0.f);
            .          R2 = Vector4D(sin(rad), cos(rad), 0.f, 0.f);
            .          break;
            .      }
            .      (*this) = (*this) * Matrix4x4( R1, R2, R3, R4 );
            .    }
            .  
            .    void scale(const Vector3D& amount)
            .    {
-- line 357 ----------------------------------------
-- line 416 ----------------------------------------
            .    Matrix4x4 ret;
            .    FastMath::MultMtx<Matrix4x4,4>::eval(ret,a,b);
            .    return ret;
            .  }
            .  
            .  inline Vector3D operator *(const Matrix4x4& M, const Vector3D& v)
            .  {
            .    return Vector3D(
  228,099,330                    v[0] * M[0][0] + v[1] * M[0][1] + v[2] * M[0][2],
  364,958,928                    v[0] * M[1][0] + v[1] * M[1][1] + v[2] * M[1][2],
  364,958,928                    v[0] * M[2][0] + v[1] * M[2][1] + v[2] * M[2][2]);
            .  }
            .  
            .  inline Point3D operator *(const Matrix4x4& M, const Point3D& p)
            .  {
            .    return Point3D(
  420,656,772                   p[0] * M[0][0] + p[1] * M[0][1] + p[2] * M[0][2] + M[0][3],
  594,250,764                   p[0] * M[1][0] + p[1] * M[1][1] + p[2] * M[1][2] + M[1][3],
  594,250,764                   p[0] * M[2][0] + p[1] * M[2][1] + p[2] * M[2][2] + M[2][3]);
            .  }
            .  
            .  inline Vector3D transNorm(const Matrix4x4& M, const Vector3D& n)
            .  {
            .    return Vector3D(
   41,580,100                    n[0] * M[0][0] + n[1] * M[1][0] + n[2] * M[2][0],
   66,528,160                    n[0] * M[0][1] + n[1] * M[1][1] + n[2] * M[2][1],
   66,528,160                    n[0] * M[0][2] + n[1] * M[1][2] + n[2] * M[2][2]);
            .  }
            .  
            .  inline std::ostream& operator <<(std::ostream& os, const Matrix4x4& M)
            .  {
            .    return os << "[" << M[0][0] << " " << M[0][1] << " " 
            .              << M[0][2] << " " << M[0][3] << "]" << std::endl
            .              << "[" << M[1][0] << " " << M[1][1] << " " 
            .              << M[1][2] << " " << M[1][3] << "]" << std::endl
-- line 450 ----------------------------------------
-- line 455 ----------------------------------------
            .  }
            .  
            .  class Colour
            .  {
            .  public:
            .    Colour(double r, double g, double b)
            .      : r_(r)
            .      , g_(g)
      554,922      , b_(b)
            .    {}
            .    Colour(double c)
            .      : r_(c)
            .      , g_(c)
            .      , b_(c)
            .    {}
            .    Colour()
            .      : r_(0.f)
            .      , g_(0.f)
            .      , b_(0.f)
            .    {}
            .    Colour(const Colour& other)
            .      : r_(other.r_)
            .      , g_(other.g_)
    1,109,706      , b_(other.b_)
            .    {}
            .  
            .    static Colour Black;
            .    static Colour White;
            .  
            .    Colour& operator =(const Colour& other)
            .    {
            2      r_ = other.r_;
            2      g_ = other.g_;
            2      b_ = other.b_;
            .      return *this;
            .    }
            .  
            .    double R() const 
            .    { 
            .      return r_;
            .    }
            .    double G() const 
-- line 496 ----------------------------------------
-- line 527 ----------------------------------------
            .  
            .  inline bool operator !=(const Colour& a, const Colour& b)
            .  {
            .    return !(a == b);
            .  }
            .  
            .  inline Colour operator *(double s, const Colour& a)
            .  {
    1,109,616    return Colour(s*a.R(), s*a.G(), s*a.B());
            .  }
            .  
            .  inline Colour operator *(const Colour& a, const Colour& b)
            .  {
            .    return Colour(a.R()*b.R(), a.G()*b.G(), a.B()*b.B());
            .  }
            .  
            .  inline Colour operator /(const Colour& a, const double& b)
            .  {
            3    return Colour(a.R()/b, a.G()/b, a.B()/b);
            .  }
            .  
            .  inline Colour operator +(const Colour& a, const Colour& b)
            .  {
            .    return Colour(a.R()+b.R(), a.G()+b.G(), a.B()+b.B());
            .  }
            .  
            .  inline std::ostream& operator <<(std::ostream& os, const Colour& c)
-- line 553 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: primitive.cpp
--------------------------------------------------------------------------------
           Ir 

-- line 15 ----------------------------------------
            .  bool Sphere::SimpleTrace(Ray R)
            .  {
            .  	R.Direction.normalize();
            .  	Vector3D deltaP = m_center - R.Start;
            .  	return (((m_radius*m_radius) - (deltaP - (R.Direction.dot(deltaP))*R.Direction).length2()) >= 0);
            .  }
            .  
            .  bool Sphere::DepthTrace(Ray R, double& closestDist, HitInfo& Hit, const Matrix4x4& M)
  156,410,952  {
            .  	R.Direction.normalize();
            .  	bool retry;
            .  	do{
            .  		retry = false;
            .  		Vector3D deltaP = m_center - R.Start;
            .  		double uDotDeltaP = R.Direction.dot(deltaP);
   39,626,580  		double discriminant = (m_radius*m_radius - (deltaP - (uDotDeltaP)*R.Direction).length2());
            .  		// std::cout << discriminant << std::endl;
   26,417,720  		if (discriminant >=0)
            .  		{
    2,188,470  			double sqrtDisc = sqrt(discriminant);
    2,188,470  			double s = std::min(uDotDeltaP + sqrtDisc, uDotDeltaP - sqrtDisc);
    1,458,980  			if (s < 0)
            .  			{
    1,610,739  				if (uDotDeltaP + sqrtDisc > 0) s = uDotDeltaP + sqrtDisc;
      554,948  				else if (uDotDeltaP - sqrtDisc > 0) s = uDotDeltaP - sqrtDisc;
            .  				else return false;
            .  			}
            .  			Vector3D rayVec = s * R.Direction;
            .  			Point3D hitLoc = R.Start + rayVec;
            .  			Vector3D Normal = (hitLoc - m_center);
            .  
            .  			Point3D WorldRay = M * R.Start;
            .  			Point3D WorldHit = M * hitLoc;
            .  			if (clampDist(closestDist, WorldRay, WorldHit, Normal, Hit, M))
            .  			{
            .  				return true;
            .  			}
            .  
      523,842  			if (CheckCloseHit(WorldRay, WorldHit))
            .  			{
            .  				R.Start = R.Start + EPSILON*R.Direction;
            .  				retry = true;
            .  			}
            .  		}
            .  	} while(retry);
   25,513,688  	return false;
  104,273,968  }
            .  
            .  Cube::~Cube()
            .  {
            .  }
            .  
            .  bool Cube::IsInside(Point3D Int, Vector3D Mask)
            .  {
   32,585,619  	bool xCheck = true, yCheck = true, zCheck = true;
  531,997,743  	Point3D Extent(m_pos[0] + m_size, m_pos[1] + m_size, m_pos[2] + m_size);
  809,303,523  	if (Mask[0] != 0) {xCheck = !(Int[0] < m_pos[0] || Int[0] > Extent[0]);}
  569,293,274  	if (Mask[1] != 0) {yCheck = !(Int[1] < m_pos[1] || Int[1] > Extent[1]);}
  618,823,917  	if (Mask[2] != 0) {zCheck = !(Int[2] < m_pos[2] || Int[2] > Extent[2]);}
  227,119,348  	return xCheck && yCheck && zCheck;
   32,585,619  }
            .  
            .  bool Cube::DepthTrace(Ray R, double& closestDist, HitInfo& Hit, const Matrix4x4& M)
  488,784,300  {
            .  	R.Direction.normalize();
            .  	Vector3D xNorm = Vector3D(1, 0, 0);
            .  	Vector3D yNorm = Vector3D(0, 1, 0);
            .  	Vector3D zNorm = Vector3D(0, 0, 1);
            .  
  391,027,440  	Vector3D Norms[6];
            .  	Norms[0] = -xNorm;
            .  	Norms[1] = -yNorm;
            .  	Norms[2] = -zNorm;
            .  	Norms[3] = xNorm;
            .  	Norms[4] = yNorm;
            .  	Norms[5] = zNorm;
            .  
            .  	bool ret, retry;
   65,171,238  	do{
  130,342,480  		ret = retry = false;
            .  		Point3D PointOnPlane = m_pos;
            .  		Vector3D Mask(1, 1, 1);
  651,712,382  		for (int i=0;i<6;i++)
            .  		{
  716,883,618  			if (i == 3)
            .  			{
            .  				PointOnPlane = m_pos + Point3D(m_size, m_size, m_size);
            .  				Mask = Vector3D(-1, -1, -1);
            .  			}
            .  			Vector3D Norm = Norms[i];
            .  			double D = SolveForD(PointOnPlane, Norm);
  977,568,570  			double S = -(D + (-SolveForD(R.Start, Norm)))/(Norm.dot(R.Direction));
  391,027,428  			if (S <= 0) continue;
            .  			Vector3D rayAdd = S*R.Direction;
            .  			Point3D rayInt = R.Start + rayAdd;
            .  			Vector3D NewMask = Mask + Norm;
1,175,170,248  			if (IsInside(rayInt, NewMask))
2,821,709,043  => primitive.cpp:Cube::IsInside(FastMath::Point<3ul, double>, FastMath::Vector<3ul, double>) (97930854x)
            .  			{
            .  				Point3D WorldRay = M * R.Start;
            .  				Point3D WorldHit = M * rayInt;
            .  				if (clampDist(closestDist, WorldRay, WorldHit, Norm, Hit, M))
            .  				{
   24,115,854  					ret = true;
            .  				}
            .  
   35,378,346  				if (CheckCloseHit(WorldRay, WorldHit))
            .  				{
            .  					R.Start = R.Start + EPSILON*R.Direction;
            .  					retry = true;
            .  				}
            .  			}
            .  		}
            .  	} while(retry);
            .  
            .  	return ret;
  293,270,571  }
            .  
            .  Cylinder::~Cylinder()
            .  {
            .  }
            .  
            .  bool Cylinder::DepthTrace(Ray R, double& closestDist, HitInfo& Hit, const Matrix4x4& M)
            .  {
            .  	R.Direction.normalize();
-- line 138 ----------------------------------------
-- line 391 ----------------------------------------
            .  // 		return true;
            .  // 	}
            .  // 	return false;
            .  // }
            .  
            .  inline bool CheckCloseHit(const Point3D& WorldRay, const Point3D& WorldHit)
            .  {
            .  	return (WorldHit - WorldRay).length() < EPSILON;
            2  }
--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jnbmoffa/git/raytracer/src/main.cpp
--------------------------------------------------------------------------------
  No information has been collected for /home/jnbmoffa/git/raytracer/src/main.cpp

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /build/buildd/eglibc-2.19/string/../sysdeps/x86_64/multiarch/memcpy-sse2-unaligned.S
  /build/buildd/eglibc-2.19/csu/libc-start.c

--------------------------------------------------------------------------------
Ir 
--------------------------------------------------------------------------------
84  percentage of events annotated

